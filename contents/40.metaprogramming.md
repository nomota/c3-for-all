# Metaprogramming


Metaprogramming is essentially writing code that writes or manipulates other code. In C3 language, we have following metaprogramming features.

* Generics
* Reflection
* Macros
* Compile time computing
* Include and exec

### Generics

In C3, generic types and generic functions are realized by generic modules.

A generic module is a module parameterized by one or more type markers, like `{T1, T2, ..}`, and all defitions in that module are accessed only by giving types respectively.

```c3
module mx; // unparameterized module

struct MyStr { int a; }
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func() { }
fn void MyStr.method(&self) { }

module my {X, Y}; // Error: type parameter name must have 2 or more chars, starting with upper char
struct S {  } // Error: struct name must have 2+ chars, starting with upper char
int I; // Error: only const var can have all upper chars 
struct MyStr { } // Error: Zero sized struct is not allowed

module mz::aa {Type1, Type2}; // parameterized module

struct MyStr { Type1 a; }
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func(Type2 arg) { }
fn void MyStr.method(&self, Type1* p) { }
```
```
// mx.c3
module main;

import mx;

fn void main()
{
    MyStr a;
    MtIfc b;
    ivar = I_CONST; // Error: globals from other module must be prefixed with module name
    mx::ivar = ma::I_CONST
    func(); // Error: functions from other module must be prefixed with module name
    mx::func();
    a.method();
}

// mz.c3

import mz;

fn void main()
{
    MyStr a; // Error: there can be a lot of different MyStr's exist. Must specify which, by giving parameter
    MyStr {char, int*} a;
    MyIfc {int, bool} b;
    ivar {int, char} = I_CONST {int, int}
}
```
}

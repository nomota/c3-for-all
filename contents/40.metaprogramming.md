# Metaprogramming


Metaprogramming is essentially writing code that writes or manipulates other code. In C3 language, we have following metaprogramming features.

* Generics
* Reflection
* Macros
* Compile time computing
* Include and exec

### Generics

In C3, generic types and generic functions are realized by generic modules.

A generic module is a module parameterized by one or more type markers, like `{T1, T2, ..}`, and all defitions in that module are accessed only by giving types respectively.

Let's look at a normal modele.

```c3
// mx
module mx; // unparameterized module

struct MyStr { int a; }
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func() { }
fn void MyStr.method(&self) { }

// main
module main;

import mx;

fn void main()
{
    MyStr a;
    MtIfc b;
    ivar = I_CONST; // Error: globals from other module must be prefixed with module name
    mx::ivar = mx::I_CONST
    func(); // Error: functions from other module must be prefixed with module name
    mx::func();
    a.method();
}
```

Let's look at parameterized generic module.

```c3
// my
module my {X, Y}; // Error: type parameter name must have 2 or more chars, starting with upper char

struct S {  } // Error: struct name must have 2+ chars, starting with upper char
int I; // Error: only const var can have all upper chars 
struct MyStr { } // Error: Zero sized struct is not allowed

// mz::aa
module mz::aa {Type1, Type2}; // parameterized module

struct MyStr { Type1 a; } // generic type
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func(Type2 arg) { } // generic function
fn void MyStr.method(&self, Type1* p) { }

// 
module main;

import mz;

fn void main()
{
    MyStr a; // Error: there can be a lot of different MyStr's exist. Must specify which, by giving parameters
    MyStr {char, int*} a;
    MyIfc {int, bool} b;
    aa::ivar = aa::I_CONST; // Error: globals from other must be prefied with module name
    ivar {int, char} = I_CONST {int, int}
}
```

# Metaprogramming


Metaprogramming is essentially writing code that writes or manipulates other code. In C3 language, we have following metaprogramming features.

* Generics
* Reflection
* Macros
* Compile time computing
* Include and exec

### Generics

In C3, generic types and generic functions are realized by generic modules.

A generic module is a module parameterized by one or more type markers, like `{T1, T2, ..}`, and all defitions in that module are accessed only by giving types respectively.

Let's look at a normal modele.

```c3
// mx
module mx; // unparameterized module

struct MyStr { int a; }
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func() { }
fn void MyStr.method(&self) { }

// main
module main;

import mx;

fn void main()
{
    MyStr a;
    MtIfc b;
    mx::ivar = mx::I_CONST;
    mx::func();
    a.method();

    ivar = I_CONST; // Error: globals from other module must be prefixed with module:: name
    func(); // Error: functions from other module must be prefixed with module:: name
}
```

Let's look at parameterized generic module and how it's being used.

```c3
// my
module my {X, Y}; // Error: type parameter name must have 2 or more chars, starting with upper char

struct S {  } // Error: struct name must have 2+ chars, starting with upper char
int I; // Error: only const var can have all upper chars 
struct MyStr { } // Error: Zero sized struct is not allowed

// mz::aa
module mz::aa {Type1, Type2}; // parameterized module

struct MyStr { Type1 a; } // generic type
interface MyIfc { }
const int I_CONST = 0;
int ivar;
fn void func(Type2 y) { } // generic function
fn void MyStr.method(&self, Type1 x) { }

// main 
module main;

import mz; // also imports submodule mz::aa

fn void main()
{    
    MyStr{char, char} a;
    MyIfc{int, bool} b;
    ivar{int, char} = I_CONST{int, int}; // aa:: not necessary
    int x = ivar{char, char};
    func{char, int}(x); // aa:: not necessary
    a.method('c');

    MyStr a; // Error: defined in generic module, but no parameters were given.
    ivar = I_CONST; // Error:: defined in generic module, but no parameters were given.        
    func(x); // Error: defined in generic module, but no parameters were given.
    func{char, char}(x); // Error: x type mismatch, should be in Type2, which is char
    a.method(x); // Error: x type mismatch, should be in Type1, which is char
}
```

It is also possible to parameterize by an int or bool constant, for example:

```c3
module custom_type {Type, VALUE};

struct Example
{
    Type[VALUE] arr;
}

module main;

import custom_type;

fn void main() 
{
    Example{int, 3} a;
}
```

Code inside a generic module may use the generic parameters as if they were well-defined symbols:

```c3
module foo_test {Type1, Type2};

struct Foo
{
   Type1 a;
}

fn Type2 test(Type2 b, Foo* foo)
{
   return foo.a + b;
}
```

Importing a generic module works as usual:

```c3
import foo_test;

alias FooFloat = Foo{float, double};
alias test_float = foo_test::test{float, double};

FooFloat f;
double x = test_float(1.0, &f);

Foo{int, double} g;
double y = foo_test::test{int, double}(1.0, &g);
```

Just like for macros/functions, optional constraints (contracts) may be added to improve compile errors:

```c3
<*
 @require $assignable(1, TypeB) && $assignable(1, TypeC)
 @require $assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)
*>
module vector {TypeA, TypeB, TypeC};

fn void testFunc() 
{
    // test here
}

/* .. code  .. */
module other;

import vector;

struct Bar {
    int a;
    int b;
}

alias testFunction = vector::testFunc{Bar, float, int}; // Error
// Parameter(s) failed validation:
//     @require "$assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)" violated.
```

### Reflection

C3 allows both compile time and runtime reflection, by providing various type properties and $-prefixed type related functions.

#### Type properties

* `<all_type>.alignof`: the alignment in bytes needed for the type.
* `<enum_type>.associated`: a slice containing the types of associated values if any.

```c3
enum Foo : int (double d, String s)
{
    BAR = { 1.0, "normal" },
    BAZ = { 2.0, "exceptional" }
}
String s = Foo.associated[0].nameof; // "double"
```

#### `inf`

*Only available for floating point types*

Returns a representation of floating point "infinity".

#### `inner`

This returns a typeid to an "inner" type. What this means is different for each type:

- Array -> the array base type.
- Bitstruct -> underlying base type.
- Distinct -> the underlying type.
- Enum -> underlying enum base type.
- Pointer -> the type being pointed to.
- Vector -> the vector base type.

It is not defined for other types.

#### `kindof`

Returns the underlying `TypeKind` as defined in std::core::types.

```c3
TypeKind kind = int.kindof; // TypeKind.SIGNED_INT
```

#### `len`

Returns the length of the array.

```c3
usz len = int[4].len; // 4
```

#### `max`

Returns the maximum value of the type (only valid for integer and float types).

```c3
ushort max_ushort = ushort.max; // 65535
```

#### `membersof`

*Only available for bitstruct, struct and union types.*

Returns a *compile time* list containing the fields in a bitstruct, struct or union. The
elements have the *compile time only* type of `member_ref`.

*Note: As the list is an "untyped" list, you are limited to iterating and accessing it at
compile time.*

```c3
struct Baz
{
    int x;
    Foo* z;
}
String x = Baz.membersof[1].nameof; // "z"
```

A `member_ref` has properties `alignof`, `kindof`, `membersof`, `nameof`, `offsetof`, `sizeof` and `typeid`.

#### `methodsof`

This property returns the methods associated with a type as a constant array of strings.

Methods are generally registered *after* types are registered, which means that the use of 
"methodsof" may return inconsistent results depending on where in the resolution cycle it is invoked.
It is always safe to use inside a function.

#### `min`

Returns the minimum value of the type (only valid for integer and float types).

```c3
ichar min_ichar = ichar.min; // -128
```

#### `nameof`

Returns the name of the type.

#### `names`

Returns a slice containing the names of an enum.

```c3
enum FooEnum
{
    BAR,
    BAZ
}
String[] x = FooEnum.names; // ["BAR", "BAZ"]
```

#### `paramsof`

*Only available for function pointer types.*
Returns a ReflectParam struct for all function pointer parameters.

```c3
alias TestFunc = fn int(int x, double f);
String s = TestFunc.paramsof[1].name; // "f"
typeid t = TestFunc.paramsof[1].type; // double.typeid
```

#### `parentof`

*Only available for bitstruct and struct types.*
Returns the typeid of the parent type.

```c3
struct Foo
{
    int a;
}

struct Bar
{
    inline Foo f;
}

String x = Bar.parentof.nameof; // "Foo"
```

#### `returns`

*Only available for function types.*
Returns the typeid of the return type.

```c3
alias TestFunc = fn int(int, double);
String s = TestFunc.returns.nameof; // "int"
```

#### `sizeof`

Returns the size in bytes for the given type, like C `sizeof`.

```c3
usz x = Foo.sizeof;
```

#### `typeid`

Returns the typeid for the given type. `alias`s will return the typeid of the underlying type. The typeid size is the same as that of an `iptr`.

```c3
typeid x = Foo.typeid;
```

#### `values`

Returns a slice containing the values of an enum.

```c3
enum FooEnum
{
    BAR,
    BAZ
}
String x = FooEnum.values[1].nameof; // "BAR"
```

### Compile time functions

There are several built-in functions to inspect the code during compile time.

- `$alignof`
- `$defined`
- `$eval`
- `$evaltype`
- `$extnameof`
- `$nameof`
- `$offsetof`
- `$qnameof`
- `$sizeof`
- `$stringify`
- `$typeof`

#### `$alignof`

Returns the alignment in bytes needed for the type or member.

```c3
module test::bar;

struct Foo
{
    int x;
    char[] y;
}
int g = 123;

$alignof(Foo.x); // => returns 4
$alignof(Foo.y); // => returns 8 on 64 bit
$alignof(Foo);   // => returns 8 on 64 bit
$alignof(g);     // => returns 4
```

#### `$defined`

Returns `true` when the expression(s) inside are defined and all sub expressions
are valid.
```c3
$defined(Foo);       // => true
$defined(Foo.x);     // => true
$defined(Foo.baz);   // => false

Foo foo = {};
// Check if a method exists:
$if $defined(foo.call):
    // Check what the method accepts:
    $switch :
       $case $defined(foo.call(1)) :
           foo.call(1);
       $default :
           // do nothing
    $endswitch
$endif

// Other way to write that:
$if $defined(foo.call, foo.call(1)):
    foo.call(1);
$endif
```

The full list of what `$defined` can check:
- `SomeType a = <expr>` - checks if `<expr>` can be used to initialize a variable of type `SomeType`
- `var $a = <expr>` - checks if `<expr>` can be compile-time evaluated.
- `*<expr>` - checks if `<expr>` can be dereferenced, `<expr>` must already be valid
- `<expr>[<index>]` - checks if indexing is valid, `<expr>` and `<index>` must
    already be valid, and when possible to check at compile-time if `<index>`
    is out of bounds this will return `false`
- `<expr>[<index>] = <value>` - same as above, but also checks if `<value>` can
    be assigned, `<expr>`, `<index>` and `<value>` must already be valid
- `<expr>.<ident1>.<ident2>` - check if `.<ident2>` is valid, `<expr>.<ident1>`
    must already be valid ("ident" is short for "identifier")
- `ident`, `#ident`, `@ident`, `IDENT`, `$$IDENT`, `$ident` - check if identifier
    exists
- `Type` - check if the type exists
- `&<expr>` - check if you can take the address of `<expr>`, `<expr>` must
    already be valid
- `&&<expr>` - check if you can take the
    [temporary address](/language-fundamentals/expressions/#_top)
    of `<expr>`, `<expr>` must already be valid
- `$eval(<expr>)` - check if the [`$eval`](#eval) evaluates to something valid,
    `<expr>` must already be valid
- `<expr>(<arg0>, ...)` - check that the arguments are valid for the `<expr>`
    macro/function, `<expr>` and all args must already be valid
- `<expr>!!` and `<expr>!` - check that `<expr>` is an
    [optional](/language-common/optionals-essential/#what-is-an-optional),
    `<expr>` must already be valid
- `<expr>?` - check that `<expr>` is a
    [fault](/language-overview/types/#the-fault-type),
    `<expr>` must already be valid
- `<expr1> binary_operator <expr2>` - check if the `binary_operator` (`+`, `-`,
    ...) is defined between the two expressions, both expressions must already
    be valid
- `(<Type>)<expr>` - check if `<expr>` can be casted to `<Type>`, both `<Type>`
    and `<expr>` must already be valid

If for example `<expr>` is not defined when trying `(<Type>)<expr>` this will
result in a compile-time error.


#### `$eval`

Converts a compile time string with the corresponding variable:

```c3
int a = 123;         // => a is now 123
$eval("a") = 222;    // => a is now 222
$eval("mymodule::fooFunc")(a); // => same as mymodule::fooFunc(a)
```

`$eval` is limited to a single, optionally path prefixed, identifier.
Consequently methods cannot be evaluated directly:

```c3
struct Foo { ... }
fn int Foo.test(Foo* f) { ... }

fn void test()
{
    void* test1 = &$eval("test"); // Works
    void* test2 = &Foo.$eval("test"); // Works
    // void* test3 = &$eval("Foo.test"); // Error
}
```

#### `$evaltype`

Similar to `$eval` but for types:

```c3
$evaltype("float") f = 12.0f;
```

#### `$extnameof`

Returns the external name of a type, variable or function. The external name is
the one used by the linker.

```c3
fn void testfn(int x) { }
String a = $extnameof(g); // => "test.bar.g";
String b = $extnameof(testfn); // => "test.bar.testfn"
```

#### `$nameof`

Returns the name of a function or variable as a string without module prefixes.

```c3
fn void test() { }
int g = 1;

String a = $nameof(g); // => "g"
String b = $nameof(test); // => "test"
```

#### `$offsetof`

Returns the offset of a member in a struct.

```c3
Foo z;
$offsetof(z.y); // => returns 8 on 64 bit, 4 on 32 bit
```

#### `$qnameof`

Returns the same as `$nameof`, but with the full module name prepended.

```c3
module abc;
fn void test() { }
int g = 1;

String a = $qnameof(g); // => "abc::g"
String b = $qnameof(test); // => "abc::test"
```

#### `$sizeof`

This is used on a value to determine the allocation size needed. `$sizeof(a)` is equivalent
to doing `$typeof(a).sizeof`. Note that this is only used on values and not on types.

```c3
$typeof(a)* x = allocate_bytes($sizeof(a));
*x = a;
```

#### `$stringify`

Returns the expression as a string. `$stringify` has a special behaviour for handling macro expression parameters, where `$stringify(#foo)` will return the expression contained in `#foo` as a string, exactly as written in the macro call's arguments, rather than simply return `"#foo"`.

Thus, for example:

```c3
import std::io;

macro @describe(#expr)
{
	io::printfn("The value of `%s` is `%s`.", $stringify(#expr), #expr);
}

fn void main()
{
	@describe(isz.sizeof);
  //Prints:
  //  The value of `isz.sizeof` is `8`.
}
```

#### `$typeof`

Returns the type of an expression or variable.

```c3
Foo f;
$typeof(f) x = f;
```

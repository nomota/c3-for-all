# Strings

C3 provides multiple string types.

* `String`: mapped to `char[]`, used as the basic string type
* `ZString`: mapped to `char*`, used for C interoperability
* `WString`: mapped to `Char16*`, used for Windows interoperability
* `DString`: is a dynamic string similar to `StringBuilder` in Java or `std::string` in C++

### String type

`String` type is mostly used type in C3, which is defined as follows.

```c3
typedef String = inline char[];
```

Within memory, `String` is exactly same as `char[]`, which means its length is fixed at first as `.len` field.

It's a 'distinct' type, not an alias to `char[]`, so it needs type casting to convert from. 

```c3
char[] a = "abc-utf8-encoded";
String b = "def-utf8-한글漢字♡";
String c = (String)a; // needs type casting, because it's distinct type
char[] d = b; // no need to cast (char[]) because it's inlined in typedef
assert(d.len == b.len);
char* h = "Hello"; // zero padded
assert(h[5] == '\0');
```

* Note: all strings in C3 are by default UTF-8 encoded,and so is C3 source code and string literals ("") in it.

* Note: string literals are zero(`'\0'`) padded just like in C, but `String` and `char[]` do not end with zero.

There are subtle differences from C in char arrays and char pointers.

```c3
char[5] h = {'H', 'e', 'l', 'l', 'o'}; // array
char[] x = &h; // array to slice
String y = (String)h[..]; // array to slice to String
assert(h == "Hello"); // Error, array needs to type cast (&array) to get slice
assert(x == "Hello"); // slice vs string literal
assert(y == "Hello"); // String vs string literal
char* z = h; // Error, array does not decay to pointer, unlike in C
char* z = &h; // array to pointer
assert(z != "Hello"); // pointer vs string literal
char* w = "Hello"; // char* from string literal
io::printfn("%s", h); // array prints [72, 101, 108, 108, 111], unlike in C                     
io::printfn("%s", x); // slice prints [72, 101, 108, 108, 111], unlike in C                      
io::printfn("%s", y); // String prints Hello
io::printfn("%s", z); // pointer prints address 0x544fd42a5d6, unlike in C
```

#### Compile time functions/macros

```c3
macro Char32* @wstring32(String $string) @builtin;
macro Char32[] @char32(String $string) @builtin;
macro WString @wstring(String $string) @builtin;
macro Char16[] @char16(String $string) @builtin;
macro String @sprintf(String $format, ...) @builtin @const;
macro double? decfloat(char[] chars, int $bits, int $emin, int sign);
macro double? hexfloat(char[] chars, int $bits, int $emin, int sign);
macro String.to_integer(self, $Type, int base = 10)
```
# Strings

C3 provides multiple string types.

* `String`: mapped to `char[]`, used as the basic string type
* `ZString`: mapped to `char*`, used for C interoperability
* `WString`: mapped to `Char16*`, used for Windows interoperability
* `DString`: is a dynamic string similar to `StringBuilder` in Java or `std::string` in C++

### String type

`String` type is mostly used type in C3, which is defined as follows.

```c3
typedef String = inline char[];
```

Within memory, `String` is exactly same as `char[]`, which means its length is fixed at first as `.len` field.

It's a 'distinct' type, not an alias to `char[]`, so it needs type casting to convert from. 

```c3
char[] a = "abc-utf8-encoded";
String b = "def-utf8-한글漢字♡";
String c = (String)a; // needs type casting, because it's distinct type
char[] d = b; // no need to cast (char[]) because it's inlined in typedef
assert(d.len == b.len);
char* h = "Hello"; // zero padded
assert(h[5] == '\0');
```

* Note: all strings in C3 are by default UTF-8 encoded,and so is C3 source code and string literals ("") in it.

* Note: string literals are zero(`'\0'`) padded just like in C, but `String` and `char[]` do not end with zero.

There are subtle differences from C in char arrays and char pointers.

```c3
char[5] h = {'H', 'e', 'l', 'l', 'o'}; // array
char[] x = &h; // array to slice
String y = (String)h[..]; // array to slice to String
assert(h == "Hello"); // Error, array needs to type cast (&array) to get slice
assert(x == "Hello"); // slice vs string literal
assert(y == "Hello"); // String vs string literal
char* z = h; // Error, array does not decay to pointer, unlike in C
char* z = &h; // array to pointer
assert(z != "Hello"); // pointer vs string literal
char* w = "Hello"; // char* from string literal
io::printfn("%s", h); // array prints [72, 101, 108, 108, 111], unlike in C                     
io::printfn("%s", x); // slice prints [72, 101, 108, 108, 111], unlike in C                      
io::printfn("%s", y); // String prints Hello
io::printfn("%s", z); // pointer prints address 0x544fd42a5d6, unlike in C
```

There are a lot of String related functions/macros ready to use in Standard Library. They are defined in `std::core::string` and you don't have to import it explicitly in your code.

We can categorize String functions/macros in three groups.

* Functions/macros without allocators
* Functions/macros with allocators
* Temporary functions/macros

#### Functions/macros without allocators

`String` is a fixed size, and there are functions/macros that do not require additional buffer or memory allocated.

```c3
String str;
bool b = char_in_set(char c, String set);
String s = str.trim(String to_trim = "\t\n\r ");
String s = str.trim_left(String to_trim = "\t\n\r ");
String s = str.trim_right(String to_trim = "\t\n\r ");
bool b = str.starts_with(String prefix);
bool b = str.ends_with(String suffix);
String s = str.strip(String prefix);
String s = str.strip_end(String suffix);
bool b = str.contains(String substr);
usz cnt = str.count(String substr);
usz? idx = str.index_of_char(char character);
usz? idx = str.index_of_chars(char[] characters);
usz? idx = str.index_of_char_from(char character, usz start_index);
usz? idx = str.rindex_of_char(char character);
usz? idx = str.index_of(String substr)
usz? idx = str.rindex_of(String substr);
void str.convert_to_lower();
void str.convert_to_upper();
int128? i128 = str.to_int128(int base = 10);
long? l = str.to_long(int base = 10);
int? i = str.to_int(int base = 10);
short? sh = str.to_short(int base = 10);
ichar? ic = str.to_ichar(int base = 10);
uint128? ui128 = str.to_uint128(int base = 10);
ulong? ul = str.to_ulong(int base = 10);
uint? ui = str.to_uint(int base = 10);
ushort? ush = str.to_ushort(int base = 10);
char? uc = str.to_uchar(int base = 10);
double? d = str.to_double();
float? f = str.to_float();
void str.convert_snake_to_pascal();
Splitter splitter = str.tokenize(String split);
Splitter splitter = str.tokenize_all(String split, bool skip_last = false);
void splitter.reset();
String? str = splitter.next();
```
#### Functions/macros with allocator

There are functions/macros that require additional memory. You need to supply allocator or buffer explicitly to them.

```
Allocator allocx;
String str;
String s = format(allocx, String fmt, args...);
String s = bformat(char[] buffer, String fmt, args...);
String s = join(allocx, String[] s, String joiner);
String s = str.replace(allocx, String needle, String new_str);
String[] strs = str.split(allocx, String delimiter, usz max = 0, bool skip_empty = false);
String[]? strs = str.split_to_buffer(String delimiter, String[] buffer, usz max = 0, bool skip_empty = false);
fn String String.concat(self, Allocator allocator, String s2)
fn String String.copy(self, Allocator allocator)
fn void String.free(&self, Allocator allocator)
fn String String.to_lower_copy(self, Allocator allocator)
fn String String.to_upper_copy(self, Allocator allocator)
fn String String.capitalize_copy(self, Allocator allocator)
fn String String.snake_to_pascal_copy(self, Allocator allocator)
fn String String.pascal_to_snake_copy(self, Allocator allocator)
macro String from_struct(Allocator allocator, x)
fn String String.escape(String s, Allocator allocator, bool strip_quotes = true)
fn String? String.unescape(String s, Allocator allocator, bool allow_unquoted = false)
fn usz escape_len(String s)
fn bool needs_escape(char c)
```

#### Compile time functions/macros

```c3
macro Char32* @wstring32(String $string) @builtin;
macro Char32[] @char32(String $string) @builtin;
macro WString @wstring(String $string) @builtin;
macro Char16[] @char16(String $string) @builtin;
macro String @sprintf(String $format, ...) @builtin @const;
macro double? decfloat(char[] chars, int $bits, int $emin, int sign);
macro double? hexfloat(char[] chars, int $bits, int $emin, int sign);
macro String.to_integer(self, $Type, int base = 10)
```
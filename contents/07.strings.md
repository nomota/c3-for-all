# Strings

C3 provides multiple string types.

* `String`: mapped to `char[]`, used as the basic string type
* `ZString`: mapped to `char*`, used for C interoperability
* `WString`: mapped to `Char16*`, used for Windows interoperability
* `DString`: dynamic string similar to `StringBuilder` in Java or `std::string` in C++

### String type

`String` type is mostly used type in C3, which is defined as follows.

```c3
typedef String = inline char[]; // 8 bit unsigned bytes
```

Within memory, `String` is exactly same as `char[]`, which means its length is fixed at first as `.len` field.

It's a 'distinct' type, not an alias to `char[]`, so it needs type casting to convert from. 

```c3
char[] a = "abc-utf8-encoded";
String b = "def-utf8-한글漢字♡";
String c = (String)a; // needs type casting, because it's distinct type
char[] d = b; // no need to cast (char[]) because it's inlined in typedef
assert(d.len == b.len);
char* h = "Hello"; // zero padded
assert(h[5] == '\0');
```

* Note: all strings in C3 are by default UTF-8 encoded,and so is C3 source code and string literals ("") in it.

* Note: string literals are zero(`'\0'`) padded just like in C, but `String` and `char[]` do not end with zero.

There are subtle differences from C in char arrays and char pointers.

```c3
char[5] h = {'H', 'e', 'l', 'l', 'o'}; // array
char[] x = &h; // array to slice
String y = (String)h[..]; // array to slice to String
assert(h == "Hello"); // Error, array needs to type cast (&array) to get slice
assert(x == "Hello"); // slice vs string literal
assert(y == "Hello"); // String vs string literal
char* z = h; // Error, array does not decay to pointer, unlike in C
char* z = &h; // array to pointer
assert(z != "Hello"); // pointer vs string literal
char* w = "Hello"; // char* from string literal
io::printfn("%s", h); // array prints [72, 101, 108, 108, 111], unlike in C                     
io::printfn("%s", x); // slice prints [72, 101, 108, 108, 111], unlike in C                      
io::printfn("%s", y); // String prints Hello
io::printfn("%s", z); // pointer prints address 0x544fd42a5d6, unlike in C
```

There are a lot of String related functions/macros ready to use in Standard Library. They are defined in `std::core::string` and you don't have to import it explicitly in your code.

We can categorize String functions/macros in three groups.

* Functions/macros without allocators
* Functions/macros with allocators
* Temporary functions/macros

#### Functions/macros without allocators

`String` is a fixed size, and there are functions/macros that do not require additional buffer or memory allocated.

```c3
String str;
bool b = string::char_in_set(char c, String set);
String s = str.trim(String to_trim = "\t\n\r ");
String s = str.trim_left(String to_trim = "\t\n\r ");
String s = str.trim_right(String to_trim = "\t\n\r ");
bool b = str.starts_with(String prefix);
bool b = str.ends_with(String suffix);
String s = str.strip(String prefix);
String s = str.strip_end(String suffix);
bool b = str.contains(String substr);
usz cnt = str.count(String substr);
usz? idx = str.index_of_char(char character);
usz? idx = str.index_of_chars(char[] characters);
usz? idx = str.index_of_char_from(char character, usz start_index);
usz? idx = str.rindex_of_char(char character);
usz? idx = str.index_of(String substr)
usz? idx = str.rindex_of(String substr);
void str.convert_to_lower();
void str.convert_to_upper();
int128? i128 = str.to_int128(int base = 10);
long? l = str.to_long(int base = 10);
int? i = str.to_int(int base = 10);
short? sh = str.to_short(int base = 10);
ichar? ic = str.to_ichar(int base = 10);
uint128? ui128 = str.to_uint128(int base = 10);
ulong? ul = str.to_ulong(int base = 10);
uint? ui = str.to_uint(int base = 10);
ushort? ush = str.to_ushort(int base = 10);
char? uc = str.to_uchar(int base = 10);
double? d = str.to_double();
float? f = str.to_float();
void str.convert_snake_to_pascal();
Splitter splitter = str.tokenize(String split);
Splitter splitter = str.tokenize_all(String split, bool skip_last = false);
void splitter.reset();
String? str = splitter.next();
```
#### Functions/macros with allocator

There are functions/macros that require additional memory. You need to supply allocator or buffer explicitly to them.

```c3
Allocator allocx;
String str;
String s = string::format(allocx, String fmt, args...);
String s = string::bformat(char[] buffer, String fmt, args...);
String s = string::join(allocx, String[] s, String joiner);
String s = str.replace(allocx, String needle, String new_str);
String[] strs = str.split(allocx, String delimiter, usz max = 0, bool skip_empty = false);
String[]? strs = str.split_to_buffer(String delimiter, String[] buffer, usz max = 0, bool skip_empty = false);
String s2 = str.concat(allocx, String s2);
String s = str.copy(allocx);
void str.free(allocx);
String s = str.to_lower_copy(allocx);
String s = str.to_upper_copy(allocx);
String s = str.capitalize_copy(allocx);
String s = str.snake_to_pascal_copy(allocx);
String s = str.pascal_to_snake_copy(allocx);
String s = string::from_struct(allocx, struct_x);
String s = str.escape(allocx, bool strip_quotes = true);
String? s = str.unescape(allocx, bool allow_unquoted = false);
usz len = string::escape_len(String s);
bool b = string::needs_escape(char c);
```

* Note: you need to use same allocator to `str.free(allocx)` that was used to get the string.

#### Temporary functions/macros

In C3, we have temporary allocator `tmem` that can be applied to `allocx` above. For convinience, there are many 't'-prefixed functions/macros as follows and they use `tmem` as allocator.

```c3
String s = string::tformat(String fmt, args...);
String s = str.treplace(String needle, String new_str);
String[] strs = str.tsplit(String delimiter, usz max = 0, bool skip_empty = false);
String s = str.tconcat(String s2);
String s = str.tcopy();
String s = str.to_lower_tcopy();
String s = str.to_upper_tcopy();
String s = str.tescape(bool strip_quotes = false);
String? s = str.tunescape(bool allow_unquoted = false);
String s = string::tfrom_struct(struct_x);
```

* Note: you have to enclose your code with `@pool(){ }` macro scope, to let all temporarily created strings get cleaned up at the end of the scope.

### ZString

`ZString` is zero terminated string and used for interaction with C language. `ZString` is defined as follows.

```c3
typedef ZString = inline char*; // pointer to unsigned bytes
```

Several functions/macros are ready to use to handle `ZString`.

```c3
ZString zstr;
String str;
Allocator allocx;
ZString zs = string::tformat_zstr(String fmt, args...);
bool b = zstr.eq(ZString other) @operator(==);
String s = zstr.str_view();
usz clen = zstr.char_len();
usz n = zstr.len();
ZString zs = str.zstr_tcopy();
String s = zstr.copy(allocx);
ZString zs = str.zstr_copy(allocx);
String s = zstr.tcopy();
```

### WString

`WString` is UTF-16 encoded and used mainly for interaction with Windows specific functions.

`WString` is defined as follows.

```c3
alias Char16 = ushort; // unsigned 16 bit
alias Char32 = uint; // unsigned 32 bit
typedef WString = inline Char16*;
```

Followings are `WString` related functions/macros. 

* Note: `Char32[]` is used for UTF-32 strings.

```c3
String str;
WString wstr;
Allocator allocx;
usz n = wstr.len();
Char16[]? c16 = str.to_utf16(allocx);
Char16[]? c16 = str.to_temp_utf16();
WString? ws = str.to_wstring(allocx);
WString? ws = str.to_temp_wstring();
Char32[]? c32 = str.to_utf32(allocx);
Char32[]? c32 = str.to_temp_utf32();
String? s = string::from_utf32(allocx, Char32[] utf32);
String? s = string::from_utf16(allocx, Char16[] utf16);
String? s = string::from_wstring(allocx, WString wstring);
String? s = string::tfrom_wstring(WString wstring);
String? s = string::tfrom_utf16(Char16[] utf16);
usz n = str.utf8_codepoints();
StringIterator str_iter = str.iterator();
void str_iter.reset();
Char32? c32 = str_iter.next();
Char32? c32 = str_iter.peek();
bool b = str_iter.has_next();
Char32? c32 = str_iter.get();
```

* Note: UTF-8 is a variable length character string, meaning that depending on the character, one character may be 1-bye, 2-bytes, 3-bytes or 4-bytes. `str.utf8_codepoints()` says how many characters are there in a string. Using `StringIterator`, we can enumerate characters one after another.

### DString

DString is for dynamic strings, that can change the size over time, similar to `StringBuilder` in Java or `std::string` in C++.

It is defined as follows.

```c3
typedef DString (OutStream) = inline void*;
```

Note that `DString` implements `OutStream` interface, by adding required functions as follows. These write given `buffer` or `c` at the end of `dstr` and the size of `dstr` grows as much. 

```c3
DString dstr;
usz? n = dstr.write(char[] buffer); // @dynamic method in OutStream
void? dstr.write_byte(char c); // @dynamic method in OutStream
```

Functions/macros for `DString` are as follows.

```c3
String str;
ZString zstr;
DString dstr;
Allocator allocx;
DString ds = dstr.init(allocx, usz capacity = MIN_CAPACITY);
DString ds = dstr.tinit(usz capacity = MIN_CAPACITY);
DString ds = dstring::new_with_capacity(allocx, usz capacity);
DString ds = dstring::temp_with_capacity(usz capacity);
DString ds = dstring::new(allocx, String c = "");
DString ds = dstring::temp(String s = "");
void dstr.replace_char(char ch, char replacement);
void dstr.replace(String needle, String replacement);
DString ds = dstr.concat(allocator, DString b);
DString ds = dstr.tconcat(DString b) 
;
ZString zs = dstr.zstr_view();
usz n = dstr.capacity();
usz n = dstr.len(); // @operator(len)
void dstr.chop(usz new_size);
String s = dstr.str_view();
char c = dstr.char_at(usz index); // @operator([])
char* p = dstr.char_ref(usz index); // @operator(&[])
usz n = dstr.append_utf32(Char32[] chars);
void dstr.set(usz index, char c); // @operator([]=)
void dstr.append_repeat(char c, usz times);
usz n = dstr.append_char32(Char32 c);
DString ds = dstr.tcopy();
DString ds = dstr.copy(allocx);
ZString zs = dstr.copy_zstr(allocx);
String s = dstr.copy_str(allocx);
String s = dstr.tcopy_str();
bool b = dstr.equals(DString other_string);
void dstr.free();
bool b = dstr.less(DString other_string);
void dstr.append_chars(String str);
Char32[] c32 = dstr.copy_utf32(allocx);
void dstr.append_string(DString str);
void dstr.clear();
void dstr.append_char(char c);
void dstr.delete_range(usz start, usz end);
void dstr.delete(usz start, usz len = 1);
void dstr.append(value)
void dstr.insert_chars_at(usz index, String s);
void dstr.insert_string_at(usz index, DString str);
void dstr.insert_char_at(usz index, char c);
usz n = dstr.insert_char32_at(usz index, Char32 c);
usz n =  dstr.insert_utf32_at(usz index, Char32[] chars);
void dstr.insert_at(usz index, value);
usz? n = dstr.appendf(String format, args...);
usz? n = dstr.appendfn(String format, args...);
DString ds = dstring::join(allocx, String[] s, String joiner);
void dstr.reverse();
fn StringData* DString.data(self) @inline @private
fn void DString.reserve(&self, usz addition)
fn usz? DString.read_from_stream(&self, InStream reader)
```
   
#### Compile time functions/macros

```c3
macro Char32* @wstring32(String $string) @builtin;
macro Char32[] @char32(String $string) @builtin;
macro WString @wstring(String $string) @builtin;
macro Char16[] @char16(String $string) @builtin;
macro String @sprintf(String $format, ...) @builtin @const;
macro double? decfloat(char[] chars, int $bits, int $emin, int sign);
macro double? hexfloat(char[] chars, int $bits, int $emin, int sign);
macro String.to_integer(self, $Type, int base = 10)
```
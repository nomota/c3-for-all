# Strings

C3 provides multiple string types.

* `String`: mapped to `char[]`, used as the basic string type
* `ZString`: mapped to `char*`, used for C interoperability
* `WString`: mapped to `Char16*`, used for Windows interoperability
* `DString`: dynamic string similar to `StringBuilder` in Java or `std::string` in C++

### String type

`String` type is mostly used type in C3, which is defined as follows.

```c3
typedef String = inline char[]; // 8 bit unsigned bytes
```

Within memory, `String` is exactly same as `char[]`, which means its length is fixed at first as `.len` field.

It's a 'distinct' type, not an alias to `char[]`, so it needs type casting to convert from. 

```c3
char[] slice = "abc-utf8-encoded";
String str = "def-utf8-ÌïúÍ∏ÄÊº¢Â≠ó‚ô°";
// String strx = slice; // Error, String is 'distinct' from char slice
String str2 = (String)slice; // Ok, needs type casting, because it's distinct type
char[] slice2 = str; // Ok, no need to cast (char[]) because it's inlined in typedef
assert(slice2.len == str.len);
char* hello = "Hello"; // zero padded
assert(hello[5] == '\0');
```

* Note: all strings in C3 are by default UTF-8 encoded, and so is C3 source code and string literals ("") in it.

* Note: string literals are zero(`'\0'`) padded just like in C, but `String` and `char[]` do not end with zero.

* Note: string literals are directly assignable to `String`, `char[]`, and `char*`. 

There are subtle differences from C in char arrays and char pointers.

```c3
char[5] array = {'H', 'e', 'l', 'l', 'o'}; // array
// char[] slicex = array; // Error, needs 'slicing' the array
char[] slice = &array; // whole array to slice
String str = (String)array[..]; // array to slice to String
// assert(array == "Hello"); // Error, array needs to type cast (&array) to get slice
assert(slice == "Hello"); // slice vs string literal
assert(str == "Hello"); // String vs string literal

// char* pointerx = array; // Error, array to pointer needs addressing, unlike in C
char* pointer = &array; // array to pointer
assert(pointer != "Hello"); // pointer vs string literal
char* pointer2 = "Hello"; // char* from string literal

io::printfn("%s", array); // array prints [72, 101, 108, 108, 111], unlike in C
io::printfn("%s", slice); // slice prints [72, 101, 108, 108, 111], unlike in C
io::printfn("%s", str); // String prints Hello
io::printfn("%s", pointer); // pointer prints address 0x544fd42a5d6, unlike in C

// libc::printf("%s\n", array); // Error, Bad address and stack trace dump
libc::printf("%s\n", &array); // &array prints Hello, despite terminating zero missing
libc::printf("%s\n", slice); // slice prints Hello
libc::printf("%s\n", str); // String prints Hello
libc::printf("%s\n", pointer); // pointer prints Hello
```

* Note: C3 clearly distinguishes `String`, `char[]`, `char[N]` and `char*`, and we can see the difference by `io::printfn()`. Traditional `libc::printf()` treats them all alike.

There are a lot of String related functions/macros ready to use in Standard Library. They are defined in `std::core::string` and you don't have to import it explicitly in your code.

We can categorize String functions/macros in three groups.

* Functions/macros without allocators
* Functions/macros with allocators
* Temporary functions/macros

#### Functions/macros without allocators

`String` is a fixed size, and there are functions/macros that do not require additional buffer or memory allocated.

```c3
String str;
bool b = string::char_in_set(char c, String set);
String s = str.trim(String to_trim = "\t\n\r ");
String s = str.trim_left(String to_trim = "\t\n\r ");
String s = str.trim_right(String to_trim = "\t\n\r ");
bool b = str.starts_with(String prefix);
bool b = str.ends_with(String suffix);
String s = str.strip(String prefix);
String s = str.strip_end(String suffix);
bool b = str.contains(String substr);
usz cnt = str.count(String substr);
usz? idx = str.index_of_char(char character);
usz? idx = str.index_of_chars(char[] characters);
usz? idx = str.index_of_char_from(char character, usz start_index);
usz? idx = str.rindex_of_char(char character);
usz? idx = str.index_of(String substr)
usz? idx = str.rindex_of(String substr);
void str.convert_to_lower(); // in place, content changes
void str.convert_to_upper(); // in place, content changes
int128? i128 = str.to_int128(int base = 10);
long? l = str.to_long(int base = 10);
int? i = str.to_int(int base = 10);
short? sh = str.to_short(int base = 10);
ichar? ic = str.to_ichar(int base = 10);
uint128? ui128 = str.to_uint128(int base = 10);
ulong? ul = str.to_ulong(int base = 10);
uint? ui = str.to_uint(int base = 10);
ushort? ush = str.to_ushort(int base = 10);
char? uc = str.to_uchar(int base = 10);
double? d = str.to_double();
float? f = str.to_float();
void str.convert_snake_to_pascal();
Splitter splitter = str.tokenize(String split);
Splitter splitter = str.tokenize_all(String split, bool skip_last = false);
void splitter.reset();
String? str = splitter.next();
```

For tokenizing a large `String` into pieces one after another, not all at once, `Splitter` gets involved as follows.

```c3
import std::collections; // for List{String}

fn void test_tokenize()
{
    String str = "A, B, C,D, E F";
    Splitter splitter = str.tokenize(", "); // by exact match
    List{String} tokens; // generic, list of strings
    while (try token = splitter.next()) {
        tokens.push(token);
    }
    assert(tokens[0] == "A");
    assert(tokens[2] == "C,D");
    assert(tokens[3] == "E F");
}
```

* Note: `str.tokenize(", ")` splits by exact match, not by `','|' '`.

#### Functions/macros with allocator

There are functions/macros that require additional memory. You need to supply allocator or buffer explicitly.

```c3
Allocator allocx;
String str;
String s = string::format(allocx, String fmt, args...);
String s = string::bformat(char[] buffer, String fmt, args...);
String s = string::join(allocx, String[] s, String joiner);
String s = str.replace(allocx, String needle, String new_str);
String[] strs = str.split(allocx, String delimiter, usz max = 0, bool skip_empty = false);
String[]? strs = str.split_to_buffer(String delimiter, String[] buffer, usz max = 0, bool skip_empty = false);
String s2 = str.concat(allocx, String s2);
String s = str.copy(allocx);
void str.free(allocx);
String s = str.to_lower_copy(allocx);
String s = str.to_upper_copy(allocx);
String s = str.capitalize_copy(allocx);
String s = str.snake_to_pascal_copy(allocx);
String s = str.pascal_to_snake_copy(allocx);
String s = string::from_struct(allocx, struct_x);
String s = str.escape(allocx, bool strip_quotes = true);
String? s = str.unescape(allocx, bool allow_unquoted = false);
usz len = string::escape_len(String s);
bool b = string::needs_escape(char c);
```

* Note: you need to use same allocator to `str.free(allocx)` that was used to get the string.

#### Temporary functions/macros

In C3, we have temporary allocator `tmem` that can be applied to `allocx` above. For convinience, there are many 't'-prefixed functions/macros as follows and they use `tmem` as allocator implicitly.

```c3
String s = string::tformat(String fmt, args...);
String s = str.treplace(String needle, String new_str);
String[] strs = str.tsplit(String delimiter, usz max = 0, bool skip_empty = false);
String s = str.tconcat(String s2);
String s = str.tcopy();
String s = str.to_lower_tcopy();
String s = str.to_upper_tcopy();
String s = str.tescape(bool strip_quotes = false);
String? s = str.tunescape(bool allow_unquoted = false);
String s = string::tfrom_struct(struct_x);
```

* Note: you have to enclose your code with `@pool(){ ... };` macro scope, to let all temporarily created strings get cleaned up at the end of the scope.

### ZString

`ZString` is zero terminated string and used for interaction with C language. `ZString` is defined as follows.

```c3
typedef ZString = inline char*; // pointer to unsigned bytes
```

Several functions/macros are ready to use to handle `ZString`.

```c3
ZString zstr;
String str;
Allocator allocx;
ZString zs = string::tformat_zstr(String fmt, args...);
bool b = zstr.eq(ZString other) @operator(==);
String s = zstr.str_view();
usz clen = zstr.char_len();
usz n = zstr.len();
ZString zs = str.zstr_tcopy();
String s = zstr.copy(allocx);
ZString zs = str.zstr_copy(allocx);
String s = zstr.tcopy();
```

* Note: `ZString` to `String` is done without extra memory (`zstr.str_view()`), but for `String` to `ZString`, you have to make a whole copy and add extra `'\0'` at the end (`str.zstr_tcopy(), str.zstr_copy(allocx)`).

### WString

`WString` is UTF-16 encoded and used mainly for interaction with Windows specific functions.

`WString` is defined as follows.

```c3
alias Char16 = ushort; // unsigned 16 bit
alias Char32 = uint; // unsigned 32 bit
typedef WString = inline Char16*;
```

Followings are `WString` related functions/macros. 

* Note: `Char32[]` is used for UTF-32 strings.

```c3
String str;
WString wstr;
Allocator allocx;
usz n = wstr.len();
Char16[]? c16 = str.to_utf16(allocx);
Char16[]? c16 = str.to_temp_utf16();
WString? ws = str.to_wstring(allocx);
WString? ws = str.to_temp_wstring();
Char32[]? c32 = str.to_utf32(allocx);
Char32[]? c32 = str.to_temp_utf32();
String? s = string::from_utf32(allocx, Char32[] utf32);
String? s = string::from_utf16(allocx, Char16[] utf16);
String? s = string::from_wstring(allocx, WString wstring);
String? s = string::tfrom_wstring(WString wstring);
String? s = string::tfrom_utf16(Char16[] utf16);
usz n = str.utf8_codepoints();
StringIterator str_iter = str.iterator();
void str_iter.reset();
Char32? c32 = str_iter.next();
Char32? c32 = str_iter.peek();
bool b = str_iter.has_next();
Char32? c32 = str_iter.get();
```

* Note: UTF-8 is a variable length character string, meaning that depending on the character, one character may be 1-bye, 2-bytes, 3-bytes or 4-bytes. `str.utf8_codepoints()` says how many characters are there in a string. Using `StringIterator`, we can enumerate characters one after another.

```c3
import std::collections; // for List{Char32}

fn Char32 c8to32(String rune_char)
{
    return rune_char.to_temp_utf32()[0]!!; // panic on error
}

fn void test_iterator() => @pool() // release temporary memory
{
    String str = "AÌïúÊº¢‚ô°√ÖüòÇ";
    assert(str.len == 1+3+3+3+2+4); // encoded in utf8

    usz n = str.utf8_codepoints();
    assert(n == 6); // 6 rune chars

    StringIterator str_iter = str.iterator();
    List{Char32} rune_chars;
    while (try c32 = str_iter) {
        rune_chars.push(c32);
    }

    assert(rune_chars.len() == n);
    assert(rune_chars[0] == c8to32("A")); // 1 byte, ASCII alphabet
    assert(rune_chars[1] == c8to32("Ìïú")); // 3 bytes, Korean alphabet
    assert(rune_chars[2] == u8to32("Êº¢")); // 3 bytes, Chinese ideogram
    assert(rune_chars[3] == c8to32("‚ô°")); // 3 bytes, special icon char
    assert(rune_chars[4] == c8to32("√Ö")); // 2 bytes, European accented char
    assert(rune_chars[5] == c8to32("üòÇ")); // 4 bytes, Emoticon
}
```

There are various functions to convert among UTF-8, UTF-16 and UTF-32.

```c3
usz? n = conv::char32_to_utf8(Char32 c, char[] output);
Char32? conv::utf8_to_char32(char* ptr, usz* size);
void conv::char32_to_utf16_unsafe(Char32 c, Char16** output);
void? conv::char16_to_utf8_unsafe(Char16 *ptr, usz *available, char** output);
usz n = conv::char32_to_utf8_unsafe(Char32 c, char** output);
usz n = conv::utf8_codepoints(String utf8);
usz n = conv::utf8len_for_utf32(Char32[] utf32);
usz n = conv::utf8len_for_utf16(Char16[] utf16);
usz n = conv::utf16len_for_utf8(String utf8);
usz n = conv::utf16len_for_utf32(Char32[] utf32);
usz? n = conv::utf32to8(Char32[] utf32, char[] utf8_buffer);
usz? n = conv::utf8to32(String utf8, Char32[] utf32_buffer);
void? conv::utf16to8_unsafe(Char16[] utf16, char* utf8_buffer);
void? conv::utf8to32_unsafe(String utf8, Char32* utf32_buffer);
void? conv::utf8to16_unsafe(String utf8, Char16* utf16_buffer);
void conv::utf32to8_unsafe(Char32[] utf32, char* utf8_buffer);
```

#### Printing multibyte chars

Note that C3's `String` is encoded in UTF-8, and most of current terminals assume UTF-8 by default. In order to print `Char16[]` or `Char32[]` as normal strings, you need to convert them into `char[]`.

```c3
import std::io;

fn Char32 c8to32(String rune_char)
{
    return rune_char.to_temp_utf32()[0]!!; // panic on error
}

fn Char16 c8to16(String rune_char)
{
    return rune_char.to_temp_utf16()[0]!!; // panic on error
}

fn String tu32to8(Char32[] c32s)
{
    return string::from_utf32(tmem, c32s)!!; // panic on error
}

fn String tu16to8(Char16[] c16s)
{
    return string::from_utf16(tmem, c16s)!!; // panic on error
}

fn Char16[] tu8to16(String u8)
{
    return u8.to_temp_utf16()!!; // panic on error
}

fn Char32[] tu8to32(String u8)
{
    return u8.to_temp_utf32()!!; // panic on error
}

fn void test_print() => @pool() // frees temporary memories
{
    Char16 c16 = c8to16("√Ö"); // 2byte European accented char
    Char32 c32 = c8to32("üî•"); // 4 byte emoji char
    Char16[] c16s = tu8to16("üòÄ‚ô°ÌïúÊº¢√äüá∞üá∑");
    Char32[] c32s = tu8to32("ùÑû√Ü√ò¬´¬ª‚òÜ‚òÖ");

    // io::printfn("%c", c16); // Error, %c doesn't allow Char16
    // io::printfn("%c", c32); // Error, %c doesn't allow Char32
    io::printfn("%s", c16s); // prints like array [ ... ] 
    io::printfn("%s", c32s); // prints like array [ ... ]

    io::printfn("%s", tu16to8(c16s)); // prints üòÄ‚ô°ÌïúÊº¢√äüá∞üá∑
    io::printfn("%s", tu32to8(c32s)); // prints ùÑû√Ü√ò¬´¬ª‚òÜ‚òÖ
}
```

#### Formatter hooking

`io::printfn()` allows user-defined formatting function to be called for `%s` format marker. If you have your own `Type` and you want to define how your data in `Type` to be printed, you can define `Type.to_format()` as follows. After that, `io::printf("%s", (Type)data)` will print data out as defined way.

```c3
fn usz? Type.to_format(&self, Formatter* f) @dynamic
{
    // write into f using
    // n = f.print()
    // n = f.printf()
    // return n_bytes written
}
```
* Note: first argument `&self` must be a reference (pointer) to the `Type` because it's a `@dynamic` function implementing the `Formatter` interface.

* Note: each call to `f.print()` returns the number of bytes actually formatted and you need to add up and return it.

* Note: pointer type is not allowed, because that causes ambiguity, i.e. `Type*.to_format()` is not allowed.

* Note: basic types like `int` or `float` doesn't work.

```c3
import std::io;

fn String tu32to8(Char32[] c32s)
{
    return string::from_utf32(tmem, c32s)!!; // panic on error
}

fn Char32[] tu8to32(String u8)
{
    return u8.to_temp_utf32()!!; // panic on error
}

fn usz? Char32[].to_format(&self, Formatter* f) @dynamic
{
    String s = tu32to8(*self);
    usz? n = f.printf("<<%s>>", s);
    return n; 
}

fn void test_format() => @pool()
{
    Char32[] c32 = tu8to32("‚ô°ÌïúÍ∏Ä‚ô°");
    io::printfn("%s", c32); // prints <<‚ô°ÌïúÍ∏Ä‚ô°>> via Char32[].to_format()
}
```
### DString

DString is for dynamic strings, that can change the size over time, similar to `StringBuilder` in Java or `std::string` in C++.

It is defined as follows.

```c3
typedef DString (OutStream) = inline void*;
```

Note that `DString` implements `OutStream` interface, by adding required `@dynamic` functions as follows. These functions write given `buffer` or `c` at the end of `dstr` and the length of `dstr` grows as much. 

```c3
DString dstr;
usz? n = dstr.write(char[] buffer); // @dynamic method in OutStream
void? dstr.write_byte(char c); // @dynamic method in OutStream
```

Functions/macros for `DString` are as follows.

```c3
String str;
ZString zstr;
DString dstr;
Allocator allocx;
DString ds = dstr.init(allocx, usz capacity = MIN_CAPACITY);
DString ds = dstr.tinit(usz capacity = MIN_CAPACITY);
DString ds = dstring::new_with_capacity(allocx, usz capacity);
DString ds = dstring::temp_with_capacity(usz capacity);
DString ds = dstring::new(allocx, String c = "");
DString ds = dstring::temp(String s = "");
void dstr.replace_char(char ch, char replacement);
void dstr.replace(String needle, String replacement);
DString ds = dstr.concat(allocator, DString b);
DString ds = dstr.tconcat(DString b);
ZString zs = dstr.zstr_view();
usz n = dstr.capacity();
usz n = dstr.len(); // @operator(len)
void dstr.chop(usz new_size);
String s = dstr.str_view();
char c = dstr.char_at(usz index); // @operator([])
char* p = dstr.char_ref(usz index); // @operator(&[])
usz n = dstr.append_utf32(Char32[] chars);
void dstr.set(usz index, char c); // @operator([]=)
void dstr.append_repeat(char c, usz times);
usz n = dstr.append_char32(Char32 c);
DString ds = dstr.tcopy();
DString ds = dstr.copy(allocx);
ZString zs = dstr.copy_zstr(allocx);
String s = dstr.copy_str(allocx);
String s = dstr.tcopy_str();
bool b = dstr.equals(DString other_string);
void dstr.free();
bool b = dstr.less(DString other_string);
void dstr.append_chars(String str);
Char32[] c32 = dstr.copy_utf32(allocx);
void dstr.append_string(DString str);
void dstr.clear();
void dstr.append_char(char c);
void dstr.delete_range(usz start, usz end);
void dstr.delete(usz start, usz len = 1);
void dstr.append(value); // value = String, char[], Char16[], Char32[], char, Char16, Char32
void dstr.insert_chars_at(usz index, String s);
void dstr.insert_string_at(usz index, DString str);
void dstr.insert_char_at(usz index, char c);
usz n = dstr.insert_char32_at(usz index, Char32 c);
usz n =  dstr.insert_utf32_at(usz index, Char32[] chars);
void dstr.insert_at(usz index, value); // value = String | char[] | Char16[] | Char32 | char | Char16 | Char32
usz? n = dstr.appendf(String format, args...);
usz? n = dstr.appendfn(String format, args...);
DString ds = dstring::join(allocx, String[] s, String joiner);
void dstr.reverse();
void dstr.reserve(&self, usz addition);
usz? n = dstr.read_from_stream(&self, InStream reader);
```
   
`DString` is used as follows.

```c3
import std::io;

fn void test_dstr() 
{
    DString dstr;
    dstr.insert_at(0, 'A'); // "A"
    dstr.insert_at(0, "XYZ"); // "XYZA"
    dstr.append('S'); // "XYZAS"
    dstr.reverse(); // "SAZYX"

    io::printfn("%s", dstr); // prints SAZYX

    dstr.free();
}
```

#### Compile time macros

These are macros only availavle at compile time.

```c3
Char32* p32 = @wstring32(String $string);
Char32[] c32 = @char32(String $string);
WString ws = @wstring(String $string);
Char16[] c16 = @char16(String $string);
String s = @sprintf(String $format, ...) @const;
double? d = decfloat(char[] chars, int $bits, int $emin, int sign);
double? d = hexfloat(char[] chars, int $bits, int $emin, int sign);
String str;
$Type i = str.to_integer($Type, int base = 10);
```
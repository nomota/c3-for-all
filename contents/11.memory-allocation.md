# Memmory Allocation

There are mutiple memory allocators available in C3.

* Default allocator
* Temp allocator
* Tracking allocator
* Arena allocator
* BackedArena allocator
* DynamicArena allocator
* OnStack allocator
* SimpleHeap allocator

All allocators conform `interface Allocator {}` requirement, so they are interchangeable each other.

* Note: Standard libraries in `std::core` are imported implicitly by the compiler. Memory allocators are defined in standard library `std::core::mem::allocator`, and you don't have to import in your code.

## Default allocator

The default allocator is mapped to `libc`'s memory allocation (LibC allocator), and these macros are available, just like in C.

```c3
void* malloc(usz size); // uninitialized
void* calloc(usz size); // fills zero
void* realloc(void* ptr, usz new_size);
void free(void* ptr);
```

To achieve better type safety, a new set of allocations are also available.

```c3
Type* p = mem::alloc(Type); // uninitialized
Type* p = mem::new(Type, {initial value});
Type[] p = mem::alloc_array(Type, usz number); // uninitalized
Type[] p = mem::new_array(Type, usz number); // zero-filled
Type* p = mem::@clone(Type value);
Type[] p = mem::@clone_slice(Type[] slice);
```

Following is a traditional way of allocating memories just like in C.

```c3
const int N = 10;

fn void test() 
{
    char* p = malloc(N); // N bytes
    p = realloc(p, N * 2);
    char[] q = ((char*)malloc(char.sizeof * N))[..N-1];

    int* r = malloc(int.sizeof * N); // N ints
    int[] s = ((int*)malloc(int.sizeof * N))[..N-1];

    free(p); free(q);
    free(r); free(s);
}
```


* Note: `malloc()` macro returns `void*`, which is easily casted to `char*` or `int*`. In order to get `char[]` slice or `int[]` slice, you need to cast the `void*` to corresponding pointer and then do slicing `[..N-1]` over the pointer.

* Note: `free()` macro is applied to any kind of pointer or slice.

* Note: there's no error handling. That's because `malloc()` does not return error optional, but panics on error. Normally memory error is critical and there's little to do in that situation, but to panic. To catch the memory error, there are special macros with `_try()` suffix.

Following is more C3 way of allocation.

```c3
fn void test() 
{
    const int N = 10;

    char* p = mem::alloc(char); // one char, uninitialized
    char* q = mem::new(char, 'c'); // initialized
    char[] r = mem::new_array(char, N); // N chars, zero filled
    char* s = mem::@clone('A');

    free(p); free(q);
    free(r); free(s);
}
```

```c3
struct MyT {
    String name;
    int birth_year;
}

const int N = 10;

fn void test()
{
    MyT* p = mem::alloc(MyT); // uninitialized
    MyT* q = mem::new(MyT, {"Charlie", 7}); // initialized
    MyT[] r = mem::alloc_array(MyT, N); // N MyT's, uninitialized
    MyT* s = mem::@clone(*q);

    free(p); free(q);
    free(r); free(s);
}
```

## defer free() in scope

In a scope { ... }, you can register `defer` statements that are to be invoked right before the exit of the scope.

There are three kinds of defers, depending on how the scope exits:
* exits normally
* exits returning an error
* exits returning a normal value.

```c3
defer { ... } // on any kind of exit
defer (catch err) { io::printfn("%s", err); }  // on error returning exit
defer try { io::printfn("ok return"); } // on value returning exit
```

A typical defer usage is like this. Put `defer free()` right after allocation.

```c3
fn void test()
{
    char* p = mem::malloc(50);
    defer free(p);

    // do the rest
} // free(p) gets invoked here
```

If you want `free()` to get invoked only when error occurs, use `defer (catch err) { free() }`.

```c3
import std::io;

fn bool file_not_found() { return true; }
fn void fill_in_data(char[] p) { p[0] = 'A'; }

fn char[]? test()
{
    char[] data = mem::new_array(char, 12); // panic on error

    defer (catch err) {
        io::printfn("Error found: %s", err);
        free(data);
    }

    if (file_not_found()) {
        // Returns error, memory gets freed
        return io::FILE_NOT_FOUND?;
    }

    fill_in_data(data);

    return data;
}
```

## Temp allocator

Temporary allocator is designed to handle temporary memory allocation, and to remove the necessity of `free()` at the point of allocation.

To use temporary allocator, there are dedicated macros as follows.

```c3
void* p = mem::tmalloc(usz size);
void* p = mem::trealloc(void* ptr, usz new_size);
Type* p = mem::talloc(Type); // uninitialized
Type* p = mem::tnew(Type, {initial value});
Type[] p = mem::temp_array(Type, usz number);
Type[] p = mem::talloc_array(Type, usz number);
Type* p = mem::@tclone(Type value);
Type[] p = mem::@tclone_slice(Type[] slice);
```

## @pool() macro scope

Temporary memory is not confined within a single scope `{ ... }` like `defer`, but it needs to be within `@pool()` macro scope, in order to get properly freed.

The `@pool()` macro, on exit, automatically frees all temporary allocations within the scope.

The `@pool()` macro scope is written like this.

```c3
fn void inner_function()
{
    char* buf2 = mem::talloc(char); // temp alloc
    char* buf3 = mem::tnew(char); // temp new
    char[] buf4 = mem::temp_array(char,10); // temp array
}

fn void test() 
{
    // do something

    @pool() {
        char* buf1 = mem::tmalloc(10); // temp malloc

        inner_function();
    }; // buf1, buf2, buf3, buf4 get freed here
    // don't miss semicolon


    // do something
}
```

`@pool()` macro scope can be nested.

```c3
fn void test()
{
    @pool() {
        char* p = mem::talloc(char);

        @pool() {
            char* q = mem::tnew(char);
        }; // q gets freed here
    }; // p gets freed here
    // don't miss semicolon
}
```

A function may get `@pool()` macro scoped by using `=>` single line function body syntax like this.

```c3
fn void test() => @pool()
{
    char* p = mem::tmalloc(500);
} // p gets freed here
```

* Note: temporary memory should not be transferred to other thread or outside scope of `@pool()` macro.

Without any explicit `@pool()` macro, temporary memories still get freed at the end of `main()`.

```c3
fn void test()
{
    char* p = mem::tnew(char, 'a');
} 

fn void main() 
{
    test();
} // p gets freed here
```


# Memmory Allocation

There are mutiple memory allocators available in C3.

* Default (heap) allocator
* Temp allocator
* LazyTemp Allocator
* Null Allocator
* Libc Allocator
* Vmem allocator
* Tracking allocator
* Arena allocator
* BackedArena allocator
* DynamicArena allocator
* OnStack allocator
* SimpleHeap allocator

All allocators conform `interface Allocator {}` requirement, so they are interchangeable each other.

* Note: Standard libraries in `std::core` are imported implicitly by the compiler. Memory allocators are defined in standard library `std::core::mem::allocator`, and you don't have to import in your code.

## Default (heap) allocator

The default (heap) allocator is mapped to `libc`'s memory allocation (Libc allocator). These macros are available, just like in C.

```c3
void* malloc(usz size); // uninitialized
void* calloc(usz size); // fills zero
void* realloc(void* ptr, usz new_size);
void free(void* ptr);
```

To achieve better type safety, a new set of allocations are also available.

```c3
Type* p = mem::alloc(Type); // uninitialized
Type* p = mem::new(Type, {initial value});
Type[] p = mem::alloc_array(Type, usz number); // uninitalized
Type[] p = mem::new_array(Type, usz number); // zero-filled
Type* p = mem::@clone(Type value);
Type[] p = mem::@clone_slice(Type[] slice);
```

Following is a traditional way of allocating memories just like in C.

```c3
const int N = 10;

fn void test() 
{
    char* p = malloc(N); // N bytes
    p = realloc(p, N * 2);
    char[] q = ((char*)malloc(char.sizeof * N))[..N-1];

    int* r = malloc(int.sizeof * N); // N ints
    int[] s = ((int*)malloc(int.sizeof * N))[..N-1];

    free(p); free(q);
    free(r); free(s);
}
```


* Note: `malloc()` macro returns `void*`, which is easily casted to `char*` or `int*`. In order to get `char[]` slice or `int[]` slice, you need to cast the `void*` to corresponding pointer and then do slicing `[..N-1]` over the pointer.

* Note: `free()` macro is applied to any kind of pointer or slice.

* Note: there's no error handling. That's because `malloc()` does not return error optional, but panics on error. Normally memory error is critical and there's little to do in that situation, but to panic. To catch the memory error, there are special macros with `_try()` suffix.

Following is more C3 way of allocation.

```c3
fn void test() 
{
    const int N = 10;

    char* p = mem::alloc(char); // one char, uninitialized
    char* q = mem::new(char, 'c'); // initialized
    char[] r = mem::new_array(char, N); // N chars, zero filled
    char* s = mem::@clone('A');

    free(p); free(q);
    free(r); free(s);
}
```

```c3
struct MyT {
    String name;
    int birth_year;
}

const int N = 10;

fn void test()
{
    MyT* p = mem::alloc(MyT); // uninitialized
    MyT* q = mem::new(MyT, {"Charlie", 7}); // initialized
    MyT[] r = mem::alloc_array(MyT, N); // N MyT's, uninitialized
    MyT* s = mem::@clone(*q);

    free(p); free(q);
    free(r); free(s);
}
```

## defer free() in scope

In a scope { ... }, you can register `defer` statements that are to be invoked right before the exit of the scope.

There are three kinds of defers, depending on how the scope exits:
* exits normally
* exits returning an error
* exits returning a normal value.

```c3
defer { ... } // on any kind of exit
defer (catch err) { io::printfn("%s", err); }  // on error returning exit
defer try { io::printfn("ok return"); } // on value returning exit
```

A typical defer usage is like this. Put `defer free()` right after allocation.

```c3
fn void test()
{
    char* p = mem::malloc(50);
    defer free(p);

    // do the rest
} // free(p) gets invoked here
```

If you want `free()` to get invoked only when error occurs, use `defer (catch err) { free() }`.

```c3
import std::io;

fn bool file_not_found() { return true; }
fn void fill_in_data(char[] p) { p[0] = 'A'; }

fn char[]? test()
{
    char[] data = mem::new_array(char, 12); // panic on error

    defer (catch err) {
        io::printfn("Error found: %s", err);
        free(data);
    }

    if (file_not_found()) {
        // Returns error, memory gets freed
        return io::FILE_NOT_FOUND?;
    }

    fill_in_data(data);

    return data;
}
```

## Temp allocator

Temporary allocator is designed to handle temporary memory allocation, and to remove the necessity of `free()` at the point of allocation.

To use temporary allocator, there are dedicated macros as follows.

```c3
void* p = mem::tmalloc(usz size);
void* p = mem::trealloc(void* ptr, usz new_size);
Type* p = mem::talloc(Type); // uninitialized
Type* p = mem::tnew(Type, {initial value});
Type[] p = mem::temp_array(Type, usz number);
Type[] p = mem::talloc_array(Type, usz number);
Type* p = mem::@tclone(Type value);
Type[] p = mem::@tclone_slice(Type[] slice);
```

## @pool() macro scope

Temporary memory is not confined within a single scope `{ ... }` like `defer`, but it needs to be within `@pool()` macro scope, in order to get properly freed.

The `@pool()` macro, on exit, automatically frees all temporary allocations within the scope.

The `@pool()` macro scope is written like this.

```c3
fn void inner_function()
{
    char* buf2 = mem::talloc(char); // temp alloc
    char* buf3 = mem::tnew(char); // temp new
    char[] buf4 = mem::temp_array(char,10); // temp array
}

fn void test() 
{
    // do something

    @pool() {
        char* buf1 = mem::tmalloc(10); // temp malloc

        inner_function();
    }; // buf1, buf2, buf3, buf4 get freed here
    // don't miss semicolon


    // do something
}
```

`@pool()` macro scope can be nested.

```c3
fn void test()
{
    @pool() {
        char* p = mem::talloc(char);

        @pool() {
            char* q = mem::tnew(char);
        }; // q gets freed here
    }; // p gets freed here
    // don't miss semicolon
}
```

A function may get `@pool()` macro scoped by using `=>` single line function body syntax like this.

```c3
fn void test() => @pool()
{
    char* p = mem::tmalloc(500);
} // p gets freed here
```

* Note: temporary memory should not be transferred to other thread or outside scope of `@pool()` macro.

Without any explicit `@pool()` macro, temporary memories still get freed at the end of `main()`.

```c3
fn void test()
{
    char* p = mem::tnew(char, 'a');
} 

fn void main() 
{
    test();
} // p gets freed here
```


### Functions that allocate

Standard library functions that allocate generally require you to pass an allocator. 

Default allocator and temporary allocators are declared as `@builtin`, and you can use it anywhere needed.
* `mem`: default heap allocator
* `tmem`: temporary allocator

```c3
List{int} list;
list.init(mem); // "list" will use the heap allocator
list.push(1);
list.push(42);
io::printn(list); // Prints "{ 1, 42 }"
list.free(); // Free the memory in the list
```

If you are using `mem`, then in general you will need to free it in some way. Either it's built into the type, such as in the `List` example above, or else you will need to handle it yourself, like in this case:

```c3
String s = string::format(mem, "Hello %s", "World"); 
// The string "s" is allocated on the heap
io::printn(s); // Prints "Hello World"
free(s); // Frees the string
```

On the other hand, if you use the temp allocator, you only need to make sure it's wrapped in a `@pool`:

```c3
@pool()
{
   List{int} list;
   list.init(tmem); // "list" will use the temp allocator
   list.push(1);
   list.push(42);
   io::printn(list);
   
   String s = string::format(tmem, "Hello %s", "World"); 
   io::printn(s);
}; // s and list are freed here, because they used temp memory
```

Because of the usefulness of the temp allocator idiom, there are often temp allocator versions of functions, prefixed "t" or "temp_":

```c3
@pool()
{
   List{int} list;
   list.tinit(); // Use the temp allocator
   list.push(1);
   list.push(42);
   
   String s = string::tformat("Hello %s", "World"); // Use the temp allocator
};
```

### Implicit initialization

Some types, such as `List`, `HashMap` and `DString` will use the temp allocator by default if they are not initialized. 

```c3
@pool()
{
   List{int} list;
   list.push(1); // Implicitly initialize with the temp allocator
   list.push(42);
   
   DString str; // DString is a dynamic string
   str.appendf("Hello %s", "World");
   // The "appendf" implicitly initializes "str" with the temp allocator
   str.insert_at(5, ",");            
   str.append("!");
   io::printn(str); // Prints Hello, World!
}; // list and str is freed here
```

This is often useful for locals, but in the case of globals, you might want the container
to default use the heap allocator. For most containers there is a `ONHEAP` constant which
allows you to statically initialize globals to use the heap allocator:

```c3
List {int} l = list::ONHEAP {int};
fn void main()
{
    l.push(1); // Implicitly allocates on the heap, not the temp allcator.
}
```

### Using other allocators

For default allocator `mem` and temp allocator `tmem`, there are abbriviated macros without having to specify `mem` or `tmem` everytime.

For other kind of allocators, following allocation macros are available, where `allocx` is an allocator (interface).

```c3
void* p = allocator::malloc(allocx, usz size);
void* p = allocator::realloc(allocx, void* ptr, usz new_size);
Type* p = allocator::alloc(allocx, Type); // uninitialized
Type* p = allocator::new(allocx, Type, {initial value});
Type[] p = allocx::new_array(allocx, Type, usz number);
Type[] p = allocator::alloc_array(allocx, Type, usz number);
Type* p = allocator::@clone(allocx, Type value);
Type[] p = allocator::@clone_slice(allocx, Type[] slice);

```

To get `allocx` here, you can use following code.
```c3
TrackingAllocator tr_alloc; // struct
Allocator allocx = &tr_alloc; // interface
```

### mem::@scoped(alloc) macro scope


### _aligned(), _with_padding() allocations

There are also more specialized functions such as `new_with_padding` and `new_aligned`, the former when you need to add additional memory at the end of the allocation, and `new_aligned` for when you have overaligned types â€“ typically vectors with alignment greater than 16.


### _try() allocations


### Which allocator to use


* Default (heap) allocator
* Temp allocator
* LazyTemp Allocator
* Null Allocator
* Libc Allocator
* Vmem allocator
* Tracking allocator
* Arena allocator
* BackedArena allocator
* DynamicArena allocator
* OnStack allocator
* SimpleHeap allocator



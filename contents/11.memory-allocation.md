# Memmory Allocation

There are mutiple memory allocators available in C3.

* Default allocator
* Temp allocator
* Tracking allocator
* Arena allocator
* BackedArena allocator
* DynamicArena allocator
* OnStack allocator
* SimpleHeap allocator

All allocators conform `interface Allocator {}` requirement, so they are interchangeable each other.

* Note: Standard libraries in `std::core` are imported implicitly by the compiler. Memory allocators are defined in standard library `std::core::mem::allocator`, and you don't have to import in your code.

## Default allocator

The default allocator is mapped to `libc`'s memory allocation (LibC allocator), and these macros are available, just like in C.

```c3
void* malloc(usz size); // uninitialized
void* calloc(usz size); // fills zero
void* realloc(void* ptr, usz new_size);
void free(void* ptr);
```

To achieve better type safety, a new set of allocations are also available.

```c3
Type* p = mem::alloc(Type); // uninitialized
Type* p = mem::new(Type, {initial value});
Type[] p = mem::alloc_array(Type, usz number); // uninitalized
Type[] p = mem::new_array(Type, usz number); // zero-filled
Type* p = mem::@clone(Type value);
```

Following is a traditional way of allocating memories just like in C.

```c3
const int N = 10;

fn void test() 
{
    char* p = malloc(N); // N bytes
    p = realloc(p, N * 2);
    char[] q = ((char*)malloc(char.sizeof * N))[..N-1];

    int* r = malloc(int.sizeof * N); // N ints
    int[] s = ((int*)malloc(int.sizeof * N))[..N-1];

    free(p); free(q);
    free(r); free(s);
}
```


* Note: `malloc()` macro returns `void*`, which is easily casted to `char*` or `int*`. In order to get `char[]` slice or `int[]` slice, you need to cast the `void*` to corresponding pointer and then do slicing `[..N-1]` over the pointer.

* Note: `free()` macro is applied to any kind of pointer or slice.

* Note: there's no error handling. That's because `malloc()` does not return error optional, but panics on error. Normally memory error is critical and there's little to do in that situation, but to panic. To catch the memory error, there are special macros with `_try()` suffix.

Following is more C3 way of allocation.

```c3
fn void test() 
{
    const int N = 10;

    char* p = mem::alloc(char); // one char, uninitialized
    char* q = mem::new(char, 'c'); // initialized
    char[] r = mem::new_array(char, N); // N chars, zero filled
    char* s = mem::@clone('A');

    free(p); free(q);
    free(r); free(s);
}
```

```c3
struct MyT {
    String name;
    int birth_year;
}

const int N = 10;

fn void test()
{
    MyT* p = mem::alloc(MyT); // uninitialized
    MyT* q = mem::new(MyT, {"Charlie", 7}); // initialized
    MyT[] r = mem::alloc_array(MyT, N); // N MyT's, uninitialized
    MyT* s = mem::@clone(*q);

    free(p); free(q);
    free(r); free(s);
}
```

## defer free() in scope

In a scope { ... }, you can register `defer` statements that are to be invoked right before the exit of the scope.

There are three kinds of defers, depending on how the scope exits:
* exits normally
* exits returning an error
* exits returning a normal value.

```c3
defer { ... } // on any kind of exit
defer (catch err) { io::printfn("%s", err); }  // on error returning exit
defer try { io::printfn("ok return"); } // on value returning exit
```

A typical defer usage is like this. Put `defer free()` right after allocation.

```c3
fn void test()
{
    char* p = mem::malloc(50);
    defer free(p);

    // do the rest
} // free(p) gets invoked here
```

If you want `free()` to get invoked only when error occurs, use `defer (catch err) { free() }`.

```c3
import std::io;

fn bool file_not_found() { return true; }
fn void fill_in_data(char[] p) { p[0] = 'A'; }

fn char[]? test()
{
    char[] data = mem::new_array(char, 12); // panic on error

    defer (catch err) {
        io::printfn("Error found: %s", err);
        free(data);
    }

    if (file_not_found()) {
        // Returns error, memory gets freed
        return io::FILE_NOT_FOUND?;
    }

    fill_in_data(data);

    return data;
}
```

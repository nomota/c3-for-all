# Memmory Allocation

There are mutiple memory allocators available in C3.

* Default allocator
* Temp allocator
* Tracking allocator
* Arena allocator
* BackedArena allocator
* DynamicArena allocator
* OnStack allocator
* SimpleHeap allocator

All allocators conform `interface Allocator {}` requirement, so they are interchangeable each other.

* Note: Standard libraries in `std::core` are imported implicitly by the compiler. Memory allocators are defined in standard library `std::core::mem::allocator`, and you don't have to import in your code.

## Default allocator

The default allocator is mapped to `libc`'s memory allocation (LibC allocator), and these macros are available, just like in C.

```c3
void* malloc(usz size); // uninitialized
void* calloc(usz size); // fills zero
void* realloc(void* ptr, usz new_size);
void free(void* ptr);
```

To achieve better type safety, a new set of allocations are also available.

```c3
Type* p = mem::alloc(Type); // uninitialized
Type* p = mem::new(Type, {initial value});
Type[] p = mem::alloc_array(Type, usz number); // uninitalized
Type[] p = mem::new_array(Type, usz number); // zero-filled
Type* p = mem::@clone(Type value);
```

Following is a traditional way of allocating memories just like in C.

```c3
const int N = 10;

fn void test() 
{
    char* p = malloc(N); // N bytes
    p = realloc(p, N * 2);
    char[] q = ((char*)malloc(char.sizeof * N))[..N-1];

    int* r = malloc(int.sizeof * N); // N ints
    int[] s = ((int*)malloc(int.sizeof * N))[..N-1];

    free(p); free(q);
    free(r); free(s);
}
```


* Note: `malloc()` macro returns `void*`, which is easily casted to `char*` or `int*`. In order to get `char[]` slice or `int[]` slice, you need to cast the `void*` to corresponding pointer and then do slicing `[..N-1]` over the pointer.

* Note: `free()` macro is applied to any kind of pointer or slice.

* Note: there's no error handling. That's because `malloc()` does not return error optional, but panics on error. Normally memory error is critical and there's little to do in that situation, but to panic. To catch the memory error, there are special macros with `_try()` suffix.

Following is more C3 way of allocation.

```c3
fn void test() 
{
    const int N = 10;

    char* p = mem::alloc(char); // one char, uninitialized
    char* q = mem::new(char, 'c'); // initialized
    char[] r = mem::new_array(char, N); // N chars, zero filled
    char* s = mem::@clone('A');

    free(p); free(q);
    free(r); free(s);
}
```

```c3
struct MyT {
    String name;
    int birth_year;
}

const int N = 10;

fn void test()
{
    MyT* p = mem::alloc(MyT); // one MyT
    MyT* q = mem::alloc(MyT); // uninitialized
    MyT* r = mem::new(MyT, {"Charlie", 7}); // initialized
    MyT[] s = mem::alloc_array(MyT, N); // N MyT's, uninitialized

    free(p); free(q);
    free(r); free(s);
}
```


# Why C3? There're Rust, Zig, Odin already.

## Why C3?

C3 is a modern successor of C, preserving the C syntax as much as possible, so that existing C/C++ developers may enjoy the modern advancements of programming languages, without extra learning. C language is universally taught to all Computer Science students, C is virtually the only choice in embedded programming, and a huge code base of C is still evolving everywhere. Staying close to C is inevitable choice.

### But why? There's Go.

Go language is a pioneer, boldly removing class and exception handling, revealing that OOP concept serves little over its complexity. Instead, Go provides easier error handling, wonderfull go routine, and garbage collection, in surprisingly simple and plain grammar.

However, mandatory garbage collection is a choking point of Go, as a low level systems programming language.

### But why? There's C++.

C++ is just too complex. Too many features have been stuffed in and nobody knows them all.

### But why? There's Rust.

Rust claims ultimate safety by introducing ownership and lifetime. It's a language that changes whole programming paradigm.

Alas however, learning curve is stiffer than any other languages on earth, which effectively impedding userbility of the language.

### But why? There's Zig.

Zig wants to be a direct sucessor of C, by giving incredible interoperability with C.

However there are things too clunky with subtle details, and the syntax is overly stubbern.

### But why? There's D.

D is something like cleaner C++. Neat grammar and mature.

But it's somewhat old fashioned. OOP, exception and garbage collection are at the heart of this language.

### But why? There are Odin, Hare, V, Nim..

These languages are somewhere around Zig. Modern and clean.

But they all made similar mistakes: you don't have to invent whole new grammar to accommodate modern programming language advancements.

### So what's different in C3?

C3 proves that it's possible to make modern progress with minimal syntax change over good old friend C. Evolution rather than revolution.

As a result, C3 remains as close to C, and provides mose core features that other languages cover.

- optionals, zero overhead error handling
- struct and methods
- interface and generic
- slice and boundsry check
- defer resource close
- SIMD vectors
- builtin build system
- versatile memory allocators
- C interoperability
- libc alternative
- extensive std libraries 
- operator overloading on numbers
- macro and compile time processing
- contracts for safety
- reflecton
- cross compile and optimization
- faster compilation
- debug and safety checks

C3 lacks these features

- garbage collection
- go routine
- async/await
- smart pointers
- class and inheritance
- exception handling

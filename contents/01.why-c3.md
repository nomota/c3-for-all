
# Why C3? There Are Already Rust, Zig, and Odin.

## Why C3?

C3 is a modern successor to C, preserving C syntax as much as possible, so that existing C/C++ developers may enjoy modern programming language advancements without extra learning. The C language is universally taught to all Computer Science students, C is virtually the only choice in embedded programming, and a huge codebase of C is still expanding everywhere. Staying close to C is an inevitable choice.

### But why? There's Go.

The Go language is a pioneer, boldly removing classes and exception handling, revealing that the OOP concept adds little value relative to its complexity. Instead, Go provides easier error handling, wonderful goroutines, and garbage collection, in surprisingly simple and plain grammar.

However, mandatory garbage collection is a choking point for Go as a low-level systems programming language.

### But why? There's C++.

C++ is just too complex. Too many features have been stuffed in, and nobody knows them all.

### But why? There's Rust.

Rust claims ultimate safety by introducing ownership and lifetimes. It's a language that changes the entire programming paradigm.

Alas, however, the learning curve is steeper than any other language on earth, which effectively impedes the usability of the language.

### But why? There's Zig.

Zig wants to be a direct successor to C by providing incredible interoperability with C.

However, there are things that are too clunky with subtle details, and the syntax is overly stubborn.

### But why? There's D.

D is something like a cleaner C++. Neat grammar and mature.

But it's somewhat old-fashioned. OOP, exceptions, and garbage collection are at the heart of this language.

### But why? There are Odin, Hare, V, Nim...

These languages are somewhere around Zig. Modern and clean.

But they all made similar mistakes: you don't have to invent a whole new grammar to accommodate modern programming language advancements.

### So what's different about C3?

C3 proves that it's possible to make modern progress with minimal syntax changes over our good old friend C. Evolution rather than revolution.

As a result, C3 remains as close to C as possible and provides most core features that other languages cover.

- optionals, zero-overhead error handling
- structs and methods
- interfaces and generics
- slices and boundary checks
- defer resource closing
- SIMD vectors
- built-in build system
- versatile memory allocators
- C interoperability
- libc alternative
- extensive standard libraries 
- operator overloading on numbers
- macros and compile-time processing
- contracts for safety
- reflection
- cross-compilation and optimization
- faster compilation
- debug and safety checks
- easier test coding

C3 lacks these features:

- garbage collection
- goroutines
- async/await
- smart pointers
- classes and inheritance
- exception handling

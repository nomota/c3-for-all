# Memory Safety

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. C3 provides various ways to work around.

### Buffer overflow


Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```c3
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by the compiler with `--sanitize=address` flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

### Slice is better than raw pointer

In order to eradicate this kind of problem, you'd better use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array (`char[N]` or `char*`), by giving start/end indexes.

```
// slicing.c3

fn void main()
{
    int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {'1', '2', '3', '4', '5'}; // array

    char[] s1 = a[0..N-1]; // slice, s1.len == 5
    assert(s1.len == N);

    char[] s2 = b[0..]; // Ok. s2.len == 5
    char[] s3 = a[0..]; // ERROR, raw pointer doesn't know end index
       
    char[] s4 = b[..N-1]; // Ok. s4.len == 5
    char[] s5 = a[..N-1]; // Ok. s5.len = 5   
    
    char[] s6 = b[..]; // Ok. s6.len == 5
    char[] s7 = a[..]; // ERROR, raw pointer doesn't know end index
  
    char[] s8 = b[..^1]; // Ok. s8.len == 5
    char[] s9 = a[..^1]; // ERROR, raw pointer doesn't know end index  
 
    char[] sa = b[1..3]; // Ok. sa.len == 3
    assert(sa[0] == '2');
    char[] sb = a[1..3]; // Ok. sb.len = 3
    sb[5] = 'a'; // ERROR, index out of bound
    
    char[] sc = b[..8]; // ERROR, buffer overflow
    char[] s9 = a[..8]; // ERROR, buffer overflow
}
```






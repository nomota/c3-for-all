# Memory Safety

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. C3 provides various ways to work around.

### Buffer overflow


Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by the compiler with `--sanitize=address` flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

### Slice is better than raw pointer

In order to eradicate this kind of problem, you'd better use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array (`char[N]` or `char*`), by giving start/end indexes.

```
// slicing.c3

fn void main()
{
    int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {1, 2, 3, 4, 5}; // array

    char[] s1 = a[0 .. N-1]; // slice, s1.len == 5
    

}
```






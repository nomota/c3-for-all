# Memory Safety

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. 

C3 provides various ways to prevent or catch them effectively.

## Unused variables

If there are unused variables in your code, that could mean that you are missing something in your code.

```c3
// unused.c3

import std::io;

fn void main()
{
    int aStackVar = 3;
    io::printf("stack: %d\n", aStackVar);
    int aStateVar = 3;
    io::printf("state: %d\n", aStackVar);
}

$ c3c compile unused.c3
$ ./unused
stack: 3
state: 3
$         (Ok? No!!!)
```

As of C3 0.7.8, the c3c compiler does check unused, but not emit any warning.

## Buffer overflow

Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```c3
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by the compiler with `--sanitize=address` flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

### Slice is better than raw pointer

In order to eradicate this kind of problem, it is better to use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array (`char[N]` or `char*`), by giving start/end indexes.

```c3
// slicing.c3

fn void main()
{
    const int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {'1', '2', '3', '4', '5'}; // array

    char[] s1 = a[0..N-1]; // slice, s1.len == 5
    assert(s1.len == N);

    char[] s2 = b[0..]; // Ok. s2.len == 5
    char[] s3 = a[0..]; // Compile ERROR, raw pointer doesn't know end index
       
    char[] s4 = b[..N-1]; // Ok. s4.len == 5
    char[] s5 = a[..N-1]; // Ok. s5.len = 5   
    
    char[] s6 = b[..]; // Ok. s6.len == 5
    char[] s7 = a[..]; // Compile ERROR, raw pointer doesn't know end index
  
    char[] s8 = b[..^1]; // Ok. s8.len == 5, ^1 means b.len-1
    char[] s9 = a[..^1]; // Compile ERROR, raw pointer doesn't know end index  
 
    char[] sa = b[1..3]; // Ok. sa.len == 3
    assert(sa[0] == '2');
    char[] sb = a[1..3]; // Ok. sb.len = 3
    sb[5] = 'a'; // Runtime ERROR, index out of bound
    
    char[] sc = b[..8]; // Compile ERROR, exceeding max index
    char[] sd = a[..8]; // Compile ERROR, exceeding max index
}
```

All arrays and slices are runtime ckecked by default and may raise 'index out of bound' error, effectively preventing buffer overflow.


## Use after free (dangling pointer)

## Memory leak

## Unsafe library function call

## Race condition (thread safety)





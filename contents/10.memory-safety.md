# Memory Safety

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. 

C3 provides various ways to prevent or catch them effectively.

## Unused variables

If there are unused variables in your code, that could mean that you are missing something in your code.

```c3
// unused.c3

import std::io;

fn void main()
{
    int aStackVar = 3;
    io::printf("stack: %d\n", aStackVar);
    int aStateVar = 3;
    io::printf("state: %d\n", aStackVar);
}

$ c3c compile unused.c3
$ ./unused
stack: 3
state: 3
$         (Ok? No!!!)
```

As of C3 0.7.8, the c3c compiler does check unused, but not emit any warning.

## Buffer overflow

Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```c3
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by the compiler with `--sanitize=address` flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

### Slice is better than raw pointer

In order to eradicate this kind of problem, it is better to use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array (`char[N]` or `char*`), by giving start/end indexes.

```c3
// slicing.c3

fn void main()
{
    const int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {'1', '2', '3', '4', '5'}; // array

    char[] s1 = a[0..N-1]; // slice, s1.len == 5
    assert(s1.len == N);

    char[] s2 = b[0..]; // Ok. s2.len == 5
    char[] s3 = a[0..]; // Compile ERROR, raw pointer doesn't know end index
       
    char[] s4 = b[..N-1]; // Ok. s4.len == 5
    char[] s5 = a[..N-1]; // Ok. s5.len = 5   
    
    char[] s6 = b[..]; // Ok. s6.len == 5
    char[] s7 = a[..]; // Compile ERROR, raw pointer doesn't know end index
  
    char[] s8 = b[..^1]; // Ok. s8.len == 5, ^1 means b.len-1
    char[] s9 = a[..^1]; // Compile ERROR, raw pointer doesn't know end index  
 
    char[] sa = b[1..3]; // Ok. sa.len == 3
    assert(sa[0] == '2');
    char[] sb = a[1..3]; // Ok. sb.len = 3
    sb[5] = 'a'; // Runtime ERROR, index out of bound
    
    char[] sc = b[..8]; // Compile ERROR, exceeding max index
    char[] sd = a[..8]; // Compile ERROR, exceeding max index
}
```

All arrays and slices are runtime ckecked by default and may raise 'index out of bound' error, effectively preventing buffer overflow.


## Use after free (dangling pointer)

There are two types of 'use-after-free' vulnerability.

One type is returning a pointer to a local variable.

```c3
// stackpointer.c3

import std::io;

fn int* foo() {
    int a = 0; // local variable in stack

    int* p = &a; // pointer to a local stack variable
    *p = 3;

    return p;
} // stack popped and variable a gets destroyed

fn void main()
{
    int* p = foo();
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile stackpointer.c3
$ ./stackpointer
53732468
$       (Error!, random number!)
```

In order to detect this kind of error, use `--sanitize=address` compiler flag.

```
$ c3c compile stackpointer.c3 --sanitize=address
$ ./stackpointer
...
==2503623==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc85e529e0 at pc 0x557e09f08ae9 bp 0x7ffc85e45030 sp 0x7ffc85e45020
...
$
```

The other is using a pointer to a memory that has already been freed. 

```c3
// useafterfree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile useafterfree.c3
$ ./useafterfree
64395426
$     (Error! random value!)
```

This type of vulnerability can also be spotted by using `--sanitize=address`.

```
$ c3c compile useafterfree.c3 --sanitize=address
$ ./useafterfree
...
==2504973==ERROR: AddressSanitizer: heap-use-after-free on address 0x502000000010 at pc 0x55dd7444bae9 bp 0x7ffcd83e9e30 sp 0x7ffcd83e9e20R
...
$
```

## Double free

Double free is when you try to free a memory that is already freed.


```c3
// doublefree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    free(p); // double free, undefined behavior
}

$ c3c compile doublefree.c3
$ ./doublefree
free(): double free detected in tcache 2
Aborted (core dumped) 
$    
```

This type of vulnerability can also be spotted by using `--sanitize=address`.

```
$ c3c compile doublefree.c3 --sanitize=address
$ ./doublefree
...
==2505511==ERROR: AddressSanitizer: attempting double-free on 0x502000000010 in thread T0:
...
$
```


## Memory leak (No free after malloc)


## Unsafe library function call

## Race condition (thread safety)





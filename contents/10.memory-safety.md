# Memory Safety in C3

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. 

C3 provides various ways to prevent or catch them effectively.

## Unused variables

If there are unused variables in your code, that could mean that you are missing something in your code.

```c3
// unused.c3

import std::io;

fn void main()
{
    int aStackVar = 3;
    io::printf("stack: %d\n", aStackVar);
    int aStateVar = 3;
    io::printf("state: %d\n", aStackVar);
}

$ c3c compile unused.c3
$ ./unused
stack: 3
state: 3
$         (Ok? No!!!)
```

As of C3 0.7.8, the c3c compiler does check unused, but not emit any warning.

## Buffer overflow

Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```c3
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by the compiler with `--sanitize=address` flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

### Slice is better than raw pointer

In order to eradicate this kind of problem, it is better to use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array (`char[N]` or `char*`), by giving start/end indexes.

```c3
// slicing.c3

fn void main()
{
    const int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {'1', '2', '3', '4', '5'}; // array

    char[] s1 = a[0..N-1]; // slice, s1.len == 5
    assert(s1.len == N);

    char[] s2 = b[0..]; // Ok. s2.len == 5
    char[] s3 = a[0..]; // Compile ERROR, raw pointer doesn't know end index
       
    char[] s4 = b[..N-1]; // Ok. s4.len == 5
    char[] s5 = a[..N-1]; // Ok. s5.len = 5   
    
    char[] s6 = b[..]; // Ok. s6.len == 5
    char[] s7 = a[..]; // Compile ERROR, raw pointer doesn't know end index
  
    char[] s8 = b[..^1]; // Ok. s8.len == 5, ^1 means b.len-1
    char[] s9 = a[..^1]; // Compile ERROR, raw pointer doesn't know end index  
 
    char[] sa = b[1..3]; // Ok. sa.len == 3
    assert(sa[0] == '2');
    char[] sb = a[1..3]; // Ok. sb.len = 3
    sb[5] = 'a'; // Runtime ERROR, index out of bound
    
    char[] sc = b[..8]; // Compile ERROR, exceeding max index
    char[] sd = a[..8]; // Compile ERROR, exceeding max index
}
```

All arrays and slices are runtime ckecked by default and may raise 'index out of bound' error, effectively preventing buffer overflow.


## Use after free (dangling pointer)

There are two types of 'use-after-free' vulnerability.

One type is returning a pointer to a local variable.

```c3
// stackpointer.c3

import std::io;

fn int* foo() {
    int a = 0; // local variable in stack

    int* p = &a; // pointer to a local stack variable
    *p = 3;

    return p;
} // stack popped and variable a gets destroyed

fn void main()
{
    int* p = foo();
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile stackpointer.c3
$ ./stackpointer
53732468
$       (Error!, random number!)
```

In order to detect this kind of error, use `--sanitize=address` compiler flag.

```
$ c3c compile stackpointer.c3 --sanitize=address
$ ./stackpointer
...
==2503623==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc85e529e0 at pc 0x557e09f08ae9 bp 0x7ffc85e45030 sp 0x7ffc85e45020
...
$
```

The other is using a pointer to a memory that has already been freed. 

```c3
// useafterfree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile useafterfree.c3
$ ./useafterfree
64395426
$     (Error! random value!)
```

This type of vulnerability can also be spotted by using `--sanitize=address`.

```
$ c3c compile useafterfree.c3 --sanitize=address
$ ./useafterfree
...
==2504973==ERROR: AddressSanitizer: heap-use-after-free on address 0x502000000010 at pc 0x55dd7444bae9 bp 0x7ffcd83e9e30 sp 0x7ffcd83e9e20R
...
$
```

## Double free

Double free is when you try to free a memory that is already freed.


```c3
// doublefree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    free(p); // double free, undefined behavior
}

$ c3c compile doublefree.c3
$ ./doublefree
free(): double free detected in tcache 2
Aborted (core dumped) 
$    
```

This type of vulnerability can also be spotted by using `--sanitize=address`.

```
$ c3c compile doublefree.c3 --sanitize=address
$ ./doublefree
...
==2505511==ERROR: AddressSanitizer: attempting double-free on 0x502000000010 in thread T0:
...
$
```

## Memory allocators in C3

There are many different allocators in C3 laguage, and three of them are most frequently used.

- Default allocator
- Temporary operator
- Tracking allocator

* Note: Memory allocators are defined in `std::core::mem::allocator`. (It is at `c3/lib/std/core/mem_allocator.c3` in standard library source.)

* Note: `std::core` modules are imported by default, and you don't have to write `import std::core` in your code.

* Note: C3's default allocator is mapped into `malloc()` in `libc`. 

* Note: There's a `@builtin` variable that is designated to the default allocator `mem` and its type is 'Allocator` interface in `std::core::mem::allocator` module.


### Default allocator

Following is a traditional way of allocating memory. `malloc()` and `free()` are `@builtin` macros.

```c3
const int N = 10;

fn void test() 
{
    char* p = malloc(N); // N bytes
    char[] q = ((char*)malloc(N))[..N-1];

    int* r = malloc(int.sizeof * N); // N ints
    int[] s = ((int*)malloc(int.sizeof * N))[..N-1];

    free(p); free(q);
    free(r); free(s);
}
```

Note that `malloc()` macro returns `void*`, which is easily casted to `char*` or `int*`. In order to get `char[]` slice or `int[]` slice, you need to cast the `void*` to corresponding pointer and then do slicing `[..N-1]` over the pointer.
 
Note that `free()` macro is applied to any kind of pointer or slice.

Note that there's no error handling. That's because `malloc()` does not return error optional, but panics on error. Normally memory error is critical and there's little to do in that situation, but to panic. To catch the memory error, there are special macros with `_try()` suffix. 

There are following allocating macros, other than `malloc()` by default allocator.

* `malloc(usz size)`
* `realloc(ptr, newsize)`
* `free(ptr)`
* `mem::malloc(usz size)`
* `mem::new(type, {initial value})`
* `mem::new_array(type, number)`
* `mem::alloc(type)`
* `mem::alloc_array(type, number)`
* `mem::realloc(ptr, usz newsize)`
* `mem::free(ptr)`

These are abbriviated from following macros, with `mem` default allocator as `allocx`.

* `allocator::malloc(allocx, usz size)`
* `allocator::new(allocx, type, {initial value})`
* `allocator::new_array(allocx, type, number)`
* `allocator::alloc(allocx, type)`
* `allocator::alloc_array(allox, type, number)`
* `allocator::realloc(allocx, ptr, newsize)`
* `allocator::free(allocx, ptr)`

Depending on the context, `allocx` allocator interface can be (1) `mem`  default allocator, or (2) `tmem` temporary allocator, or (3) user selected allocator like TrackingAllocator.

Following is more C3 way of allocation. Depending on the context, allocators may differ. Most often, default allocator `mem` is used.


```c3
fn void test() 
{
    const int N = 10;
    char* p = mem::malloc(N); // N bytes
    char* q = mem::alloc(char); // one char
    char* r = mem::new(char); // uninitialized
    char* s = mem::new(char, 'c'); // initialized
    char[] t = mem::new_array(char, N); // N chars

    free(p); free(q);
    free(r); free(s);
}
```

```c3
struct MyT {
    String name;
    int birth_year;
}

const int N = 10;

fn void test()
{
    MyT* q = mem::alloc(MyT); // one MyT
    MyT* r = mem::new(MyT); // uninitialized
    MyT* s = mem::new(MyT, {"Charlie", 7}); // initialized
    MyT[] t = mem::new_array(MyT, N); // N MyT's

    free(p); free(q);
    free(r); free(s);
}
```

If you want to catch memory errors, these macros are available. It's not recommended, because underlying `libc`'s `malloc()` itself is not stable on memory error situation. Use these when you are absolutely sure about what you're doing.

```c3
char*? p = allocator::malloc_try(allocx, size);
Type*? q = allocator::alloc_try(allocx, Type);
Type*? r = allocator::new_try(allocx, Type, {initial value});
Type[]? s = allocatot::new_array_try(allox, Type, num);
```

You can simplify by defining your own macro.

```
macro void*? malloc_try(usz size) @builtin => allocator::malloc_try(mem, size);
```

## Memory leak (No free after malloc)

If your memory is used locally within a single scope `{ ... }` then C3 provides three different ways of automatic `free()` to prevent memory leak.

### (1) defer free() in scope

A scope is range of statements within `{ ... }` and you can register `defer` statements that are to be invoked right before the exit of the scope.

You can register multiple defers in a single scope, and they are invoked in reverse order.

There are three kinds of defers, depending on how the scope exits -- (a) exits normally, (b) exits returning an error, (c) exits returning a normal value.

```
defer { ... }; // on exit
defer (catch err) { io::printfn("%s", err); }  // on error returning exit
defer try { io::printfn("ok return"); } // on value returning exit
```

A typical defer usage is like this.

```c3
fn void test()
{
    char* p = mem::malloc(50);
    defer free(p);

    // do the rest
} // free(p) gets invoked here
```

If you want to free() only when error occurs.

```c3
import std::io;

fn char[]? test()
{
    char[] data = mem::new_array(char, 12); // panic on error

    defer (catch err) {
        io::printfn("Error found: %s", err)
        free(data);
    }

    if (file_not_found()) {
        // Returns error, memory gets freed
        return io::FILE_NOT_FOUND?;
    }

    fill_in_data_from_file(data);

    return data;
}
```


### (2) Temporary allocator within @pool() macro

The `@pool()` macro automatically frees all temporary allocations within the region.

There are three ways to designate the `@pool()` region.

```c3
fn void inner_function()
{
    char* buf2 = mem::talloc(char); // temp alloc
    char* buf3 = mem::tnew(char); // temp new
    char[] buf4 = mem::temp_array(char,10); // temp array
}

fn void test() 
{
    // do something

    @pool() {
        char* buf1 = mem::tmalloc(10); // temp malloc

        inner_function();
    }; // buf1, buf2, buf3, buf4 get freed here


    // do something
}


### (3) Special functions that uses temporary allocator

## @scoped() region with different allocator

## TrackingAllocator to spot leaks


## Unsafe library function call

## Race condition (thread safety)



## Flags in project.json


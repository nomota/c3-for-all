# Memory Safety in C3

There are a lot of intrinsic memory related vulnerabilities in C, which are inherited to C3. 

C3 provides various ways to prevent or catch them effectively.

### Unused variables

If there are unused variables in your code, that could mean that you are missing something in your code.

```c3
// unused.c3

import std::io;

fn void main()
{
    int aStackVar = 3;
    io::printf("stack: %d\n", aStackVar);
    int aStateVar = 3;
    io::printf("state: %d\n", aStackVar);
}

$ c3c compile unused.c3
$ ./unused
stack: 3
state: 3
$         (Ok? No! Unused var hides silently)
```

* Note: As of C3-0.7.8, the c3c compiler does check unused, but not emit any warning.

* Comparison: Zig emits compile error. Rust emits warning.

## Buffer overflow

Pointer arithmetic is a notorious source of buffer overflow. It's not easily detected by default compilation.

```c3
// bufferoverflow1.c3
fn void main()
{
    char* buffer = malloc(char.sizeof * 10);
    char* p = buffer + 20; // Wrong pointer arithmetic
    *p = 'A'; // ERROR, undefined behavior
}

$ c3c compile bufferoverflow1.c3
$ ./bufferoverflow1
$     (No error!! Silent.)
```

Address sanitizer can be attached  by using `--sanitize=address` compiler flag.

```
$ c3c compile bufferoverflow1.c3 --sanitize=address
$ ./bufferoverflow1
...
==2433408==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x502000000024 
...
SUMMARY: AddressSanitizer: heap-buffer-overflow /home/user/c3/bufferoverflow1.c3:6 in bufferoverflow1.main                       
...
```

* Comparison: Zig does not allow pointer arithmetic for simple pointer `*T`. There's a special kind of pointer `[*]T`, only which allows pointer arithmetic, and possibly overflow. Rust allows raw pointer arithmetic only within [unsafe] marked region.  

### Slice is better than raw pointer

In order to eradicate this kind of problem, it is better to use slice (`char[]`) rather than raw pointer (`char*`). Slice remembers the length of the sliced data: `<sliced>.len`

To get a slice (`char[]`), you need to do 'slicing' over the array or pointer (`char[N]` or `char*`), by giving start/end indexes.

```c3
// slicing.c3

fn void main()
{
    const int N = 5;
    char* a = malloc(N); // raw pointer
    char[N] b = {'1', '2', '3', '4', '5'}; // array

    char[] s1 = a[0..N-1]; // slice, s1.len == 5
    assert(s1.len == N);

    char[] s2 = b[0..]; // Ok. s2.len == 5
    char[] s3 = a[0..]; // Compile ERROR, raw pointer doesn't know end index
       
    char[] s4 = b[..N-1]; // Ok. s4.len == 5
    char[] s5 = a[..N-1]; // Ok. s5.len = 5   
    
    char[] s6 = b[..]; // Ok. s6.len == 5
    char[] s7 = a[..]; // Compile ERROR, raw pointer doesn't know end index
  
    char[] s8 = b[..^1]; // Ok. s8.len == 5, ^1 means b.len-1
    char[] s9 = a[..^1]; // Compile ERROR, raw pointer doesn't know end index  
 
    char[] sa = b[1..3]; // Ok. sa.len == 3
    assert(sa[0] == '2');
    char[] sb = a[1..3]; // Ok. sb.len = 3
    sb[5] = 'a'; // Runtime ERROR, index out of bound
    
    char[] sc = b[..8]; // Compile ERROR, exceeding max index
    char[] sd = a[..8]; // Compile ERROR, exceeding max index
}
```

All arrays and slices are runtime ckecked by default and may raise 'index out of bound' error, effectively preventing buffer overflow.

* Comparison: Zig allows boundary check switched off at unsafe optimized compilation. Rust always check boundaries.
 
### Use after free (dangling pointer)

There are two types of 'use-after-free' vulnerabilities.

One type is returning a pointer to a local variable.

```c3
// stackpointer.c3

import std::io;

fn int* foo() 
{
    int a = 0; // local variable in stack

    int* p = &a; // pointer to a local stack variable
    *p = 3;

    return p;
} // stack popped and variable a gets destroyed

fn void main()
{
    int* p = foo();
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile stackpointer.c3
$ ./stackpointer
53732468
$       (Error!, random number!)
```

In order to detect this kind of error, use `--sanitize=address` compiler flag.

```
$ c3c compile stackpointer.c3 --sanitize=address
$ ./stackpointer
...
==2503623==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc85e529e0 at pc 0x557e09f08ae9 bp 0x7ffc85e45030 sp 0x7ffc85e45020
...
$
```

* Comparison: Zig does static analysis and emits compile error. Rust's ownership/lifetime check emits compiler error.

The other is using a pointer to a memory that has already been free'd. 

```c3
// useafterfree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    io::printfn("%d", *p); // use after free, undefined behavior
}

$ c3c compile useafterfree.c3
$ ./useafterfree
64395426
$     (Error! random value!)
```

This type of vulnerability can also be spotted by using `--sanitize=address` compiler flag.

```
$ c3c compile useafterfree.c3 --sanitize=address
$ ./useafterfree
...
==2504973==ERROR: AddressSanitizer: heap-use-after-free on address 0x502000000010 at pc 0x55dd7444bae9 bp 0x7ffcd83e9e30 sp 0x7ffcd83e9e20R
...
$
```

* Comparison: Zig's GeneralPurpose allocator detects this at runtime. Rust's ownership/lifetime checker emits compile error.

## Double free

Double free is when you try to free a memory that has already been free'd.


```c3
// doublefree.c3

import std::io;

fn void main() 
{
    int* p;

    {
        int* q = malloc(int.sizeof);
        *q = 3;
        p = q;
        free(q);
    }
    
    free(p); // double free, undefined behavior
}

$ c3c compile doublefree.c3
$ ./doublefree
free(): double free detected in tcache 2
Aborted (core dumped) 
$    
```

This type of vulnerability can also be spotted by using `--sanitize=address` compiler flag.

```
$ c3c compile doublefree.c3 --sanitize=address
$ ./doublefree
...
==2505511==ERROR: AddressSanitizer: attempting double-free on 0x502000000010 in thread T0:
...
$
```

* Comparison: Zig's GeneralPurpose allocator detects this at runtime. Rust's ownership/lifetime checker emits compile error.

### Memory allocators in C3

There are many different allocators in C3 language, and these are most frequently used.

- Default (heap) allocator (`mem`)
- Temporary allocator (`tmem`)
- OnStack allocator
- Tracking allocator

In combination with following things each, we can effectively prevent or spot the notorious vulnerability of memory leaks, without much of trouble.

- `defer free()`
- `@pool()` macro scope
- `@stack_pool(size)` macro scope
- `@assert_leak()` macro scope

* Note: These are defined in `std::core::mem` and `std::core` modules are imported by default, so you don't have to write `import std::core` in your code.

### defer free() in scope

In a scope, you can register `defer` statements that are to be invoked before the exit of the scope.

There are three kinds of defers, depending on how the scope exits.

```c3
defer { ... }; // on any kind of exits
defer (catch err) { io::printfn("%s", err); }  // on error returning exit
defer try { io::printfn("ok return"); } // on value returning exit
```

A typical `defer` usage is like this. Putting `defer free()` right after the allocation is a good habit.

```c3
fn void test()
{
    char* p = mem::malloc(50);
    defer free(p);

    // do the rest
} // free(p) gets invoked here
```

If you want to free() only when error occurs.

```c3
import std::io;

fn bool file_not_found() { return true; }
fn void fill_in_data(char[] p) { p[0] = 'A'; }

fn char[]? test()
{
    char[] data = mem::new_array(char, 12);

    defer (catch err) {
        io::printfn("Error found: %s", err)
        free(data);
    }

    if (file_not_found()) {
        // deferred (catch err) gets invoked here and free
        return io::FILE_NOT_FOUND?;
    }

    fill_in_data(data);

    return data;
}
```

* Comparison: Zig supports `defer` and `errdefer` similar way. Rust's ownership/lifetime checker releases data without explicit `free()`.
 
### Tempo allocator and @pool()

The `@pool()` is a macro and it acts like a scope region. It automatically frees all temporary allocations within the region. It works using Temp allocator.

Temporary allocation is done by special kinds of functions/macros, all prefixed with 't'.

```c3
void* p = tmalloc(usz size);
void* p = tcalloc(usz size); // fills zero
void* p = trealloc(void* ptr, usz new_size);
Type* p = mem::talloc(Type); // uninitialized
Type* p = mem::tnew(Type[, {initial value}]); // zero filled if no initial value
Type[] p = mem::temp_array(Type, usz number);
Type[] p = mem::talloc_array(Type, usz number);
Type* p = @tclone(Type value);
Type[] p = @tclone_slice(Type[] slice);
```

This shows how to use `@pool()` macro scope.

```c3
fn void inner_function()
{
    char* buf2 = mem::talloc(char); // temp alloc
    char* buf3 = mem::tnew(char); // temp new
    char[] buf4 = mem::temp_array(char,10); // temp array
}

fn void test() 
{   
    char[] bufx;
 
    // do something

    @pool() {
        char* buf1 = mem::tmalloc(10); // temp malloc
        bufx = mem::alloc_array(char, 10); // in heap by default allocator 'mem'

        inner_function();
    }; // buf1, buf2, buf3, buf4 get free'd here
    // don't miss semicolon

    // do something

    free(bufx); // needs to be free'd explicitly
}

* Note: `@pool()` scope can be nested. The `main()` function acts like a `@pool()` scope and eventually releases all temporary allocations, which are alive even at the end of a program.

* Comparison: Zig requires explicit free/destroy all the time. Rust's ownershil/lifetime checker releases data without explicit free/destroy.

### OnStack allocator and @stack_pool(size)

The `@stack_pool(size)` is very similar to `@pool()`, but it works over non-temporary allocations. It automatically frees all non-temporary allocations within the region. It works using OnStack allocator.

Non-temporary allocation is done by normal allocating functions/macros, without 't'-prefix.

```c3
void* p = malloc(usz size);
void* p = calloc(usz size); // fills zero
void* p = realloc(void* ptr, usz new_size);
Type* p = mem::alloc(Type); // uninitialized
Type* p = mem::new(Type[, {initial value}]); // zero filled if no initial value
Type[] p = mem::new_array(Type, usz number);
Type[] p = mem::alloc_array(Type, usz number);
Type* p = @clone(Type value);
Type[] p = @clone_slice(Type[] slice);
```

This shows how to use `@stack_pool(size)` macro scope.

```c3
fn void inner_function()
{
    char* buf2 = mem::alloc(char); // normal alloc
    char* buf3 = mem::new(char); // normal new
    char[] buf4 = mem::new_array(char,10); // normal array
}

fn void test() 
{   
    char[] bufx;
 
    // do something

    @stack_pool(1024) {
        char* buf1 = mem::malloc(10); // normal malloc
        bufx = mem::talloc_array(char, 10); // using temp allocator 'tmem'

        inner_function();
    }; // buf1, buf2, buf3, buf4 get free'd here
    // don't miss semicolon

    // do something

    free(bufx); // needs to be free'd explicitly, if this function is not inside of other @pool() scope
}

* Note: `@stack_pool(size)` scope can be nested.

* Comparison: Zig requires explicit free/destroy all the time. Rust's ownershil/lifetime checker releases data without explicit free/destroy.

### Tracking allocator and @assert_leak()

The `@assert_leak()` is simple and powerful macro scope to detect leaks of non-temporary allocation. It works with Tracking allocator.

```c3
@assert_leak() {

    // put any code here in doubt

}; // reports if leak occurred, or keeps silent if no leak
// don't forget semicolon
```

* Comparison: Zig's GeneralPurpose allocator reports leaks if any. Rust's ownership/lifetime checker releases memory and leak is prevented by compiler.


### Unsafe library function calls

### Race condition (thread safety)



### Compiler flags and build options

TO DO

There are compiler flags that affects memory safrty.

There are build options in `project.json` that affects memory safety.

